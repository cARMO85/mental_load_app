The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
README.md
# Mental Load Coach (Streamlit)

A gentle, research-informed tool that helps couples see the *invisible* work and agree one small, 7-day experiment.

## Quick start
```bash
python -m venv .venv
source .venv/bin/activate        # Windows: .venv\Scripts\activate
pip install -r requirements.txt
streamlit run app.py

----
app.py
import streamlit as st
from pathlib import Path

from state import init_state, reset_state
from screens.home import screen_home
from screens.consent import screen_consent
from screens.setup import screen_setup
from screens.questionnaire import screen_questionnaire
from screens.results import screen_results
from screens.learnmore import screen_learn_more

st.set_page_config(page_title="Mental Load Coach", page_icon="🧠", layout="wide")

# ---- CSS ----
def load_css():
    css_path = Path("assets/style.css")
    if css_path.exists():
        st.markdown(f"<style>{css_path.read_text(encoding='utf-8')}</style>", unsafe_allow_html=True)
load_css()

# ---- Init ----
init_state()

# ---- CONDITIONAL NAVIGATION (best practice: hide during conversion moments) ----
stage = st.session_state.stage

# Only show full navigation on non-critical stages
if stage not in ["questionnaire", "results", "results_main"]:
    with st.sidebar:
        st.markdown("### Navigation")
        if st.button("🏠 Home"):             st.session_state.stage = "home"
        if st.button("✅ Consent"):          st.session_state.stage = "consent"
        if st.button("⚙️ Setup"):           st.session_state.stage = "setup"
        if st.button("📝 Questionnaire"):    st.session_state.stage = "questionnaire"
        if st.button("📊 Results"):          st.session_state.stage = "results"
        st.divider()
        if st.button("🔁 Start again"):
            reset_state()
            st.session_state.stage = "home"
        
        st.caption("You can return here at any time.")
else:
    # Minimal sidebar during critical stages - just emergency exit
    with st.sidebar:
        st.markdown("### 🧠 Mental Load Coach")
        st.caption("Working through the questionnaire...")
        st.markdown("---")
        st.caption("⚠️ **Important:** Try to complete in one go for best results.")
        st.markdown("")
        if st.button("🚪 Exit & restart", type="secondary", use_container_width=True):
            if st.session_state.get('confirm_exit', False):
                reset_state()
                st.session_state.stage = "home"
                st.rerun()
            else:
                st.session_state.confirm_exit = True
                st.warning("Click again to confirm - you'll lose your progress")
        
        if st.session_state.get('confirm_exit', False):
            st.caption("☝️ Click exit button again to confirm")

# ---- Router ----
if stage == "home":
    screen_home()
elif stage == "consent":
    screen_consent()
elif stage == "setup":
    screen_setup()
elif stage == "questionnaire":
    screen_questionnaire()
elif stage == "results" or stage == "results_main":
    screen_results()
elif stage == "learn_more":
    screen_learn_more()
else:
    st.session_state.stage = "home"
    screen_home()
----
assets/style.css
/* ===== Base ===== */
:root{
  --bg:#f7fafc; --card:#ffffff; --muted:#64748b;
  --ring:#cbd5e1; --ink:#0f172a; --blue:#2563eb; --green:#16a34a; --amber:#ca8a04; --red:#dc2626;
}
html,body{background:var(--bg)!important;}
.main > div {max-width: 1100px; margin: 0 auto;}

/* Typography */
h1,h2,h3{letter-spacing:.2px}
h1{font-weight:800}
h2{font-weight:700;margin-top:.5rem}
h3{font-weight:700;margin-top:.25rem}
p,li{line-height:1.6}

/* Cards / hero */
.card {
  background: var(--card);
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 2px 8px rgba(0,0,0,.04);
  margin: .5rem 0;
}
.hero{background:linear-gradient(135deg,#eef2ff,#f0f9ff);border:1px solid #e5e7eb;border-radius:16px;padding:26px 22px;margin:6px 0 22px}

/* Coach rail */
.coach{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;position:sticky;top:12px}
.coach .title{font-weight:700}
.coach small{color:var(--muted)}

/* Banner */
.banner{background:#eff6ff;border:1px solid #bfdbfe;padding:12px;border-radius:10px;color:#1e40af}

/* Pills / micro hints */
.pill { display:inline-block; padding:4px 10px; border-radius:999px; background:#eef2ff; color:#1d4ed8; font-weight:600; font-size:.80rem; }
.pill-step { background:#f1f5f9; color:#0f172a; }
.pill-label { margin-left:6px; color:#334155; font-size:.85rem; }
.micro-hint { color:#475569; font-size:.9rem; margin:2px 0 8px; }

/* Examples block */
.examples { background:#f8fafc; border:1px solid #e2e8f0; border-radius:10px; padding:10px 12px; margin:8px 0 6px; }
.examples ul { margin:4px 0 0 18px; }

/* Definition box */
.defbox { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:14px; box-shadow:0 1px 4px rgba(0,0,0,.03); }
.defbox-title { font-weight:700; margin-bottom:6px; }
.defbox-text { color:#334155; margin-bottom:8px; }
.defbox-subtitle { font-weight:600; color:#1f2937; margin-top:4px; margin-bottom:2px; }
.defbox-li { color:#374151; margin-left:4px; }
.defbox-note { margin-top:8px; font-size:.85rem; color:#475569; background:#f8fafc; border:1px dashed #cbd5e1; padding:8px; border-radius:8px; }

/* Slider spacing – keep controls separated */
.stSlider { margin: 6px 0 16px; }
.stSlider label { font-weight:600; margin-bottom: 2px; }
.stSlider [data-baseweb="slider"] { margin-top: 6px; }

/* Notes textarea */
textarea{border-radius:10px !important}

/* Plot spacing */
.blockpad{padding:8px 0}

/* Footer (if you add sticky) */
.footer{position:sticky;bottom:0;z-index:5;background:rgba(255,255,255,.9);backdrop-filter:saturate(180%) blur(6px);border-top:1px solid #e5e7eb;margin-top:16px}
.footer .row{display:flex;justify-content:space-between;align-items:center;padding:10px 6px}
.footer .left{color:#475569;font-size:.9rem}

/* Dataframe trim */
.dataframe td, .dataframe th { border: none !important; }
.dataframe tr { border-bottom: 1px solid #eee; }

.kpi-title { font-size: 0.9rem; color: #475569; font-weight: 600; }
.kpi-value { font-size: 1.8rem; font-weight: 800; line-height: 1.2; margin-top: 4px; color: #0f172a; }
.kpi-caption { font-size: 0.8rem; color: #64748b; margin-top: 2px; }



----
logic.py
from typing import List, Dict, Tuple
from models import Response

class Calculator:
    def __init__(self, responses: List[Response]):
        self.responses = [r for r in responses if not r.not_applicable]

    def _shares(self) -> Tuple[int,int]:
        # Invisible share: average responsibility across tasks
        if not self.responses:
            return 50, 50
        b_share = sum(r.responsibility for r in self.responses)/ (100*len(self.responses))
        a_pct = round((1 - b_share) * 100)
        b_pct = 100 - a_pct
        return a_pct, b_pct

    def _burden(self) -> Tuple[int,int]:
        # Map burden (1..5) to 20..100 and weight by share
        if not self.responses: return 0,0
        def scale(b): return 20*b
        a_sum = 0.0; b_sum = 0.0; n = 0
        for r in self.responses:
            n += 1
            a_share = (100 - r.responsibility)/100
            b_share = r.responsibility/100
            a_sum += scale(r.burden) * a_share
            b_sum += scale(r.burden) * b_share
        return round(a_sum/n), round(b_sum/n)

    def pillar_scores(self) -> Dict[str, Tuple[float,float]]:
        d: Dict[str, Tuple[float,float]] = {}
        for r in self.responses:
            a_share = (100 - r.responsibility)/100
            b_share = r.responsibility/100
            a = d.get(r.task.pillar, (0.0,0.0))[0] + a_share*r.burden
            b = d.get(r.task.pillar, (0.0,0.0))[1] + b_share*r.burden
            d[r.task.pillar] = (a,b)
        return d

    def compute(self) -> Dict:
        a_pct, b_pct = self._shares()
        a_burden, b_burden = self._burden()
        return dict(
            my_share_pct=a_pct, partner_share_pct=b_pct,
            my_burden=a_burden, partner_burden=b_burden,
            pillar_scores=self.pillar_scores()
        )

    @staticmethod
    def detect_hotspots(responses: List[Response]) -> List[Dict]:
        """
        Detect areas worth exploring in conversation.
        
        UPDATED LOGIC:
        - Responsibility imbalance (≥30 points from 50/50)
        - High burden (≥4 on 1-5 scale)
        - Low fairness (≤3 on 1-5 scale)
        - NEW: Combined flag for imbalance + unfairness
        """
        out = []
        for r in responses:
            reasons = []
            
            # Check responsibility imbalance
            responsibility_diff = abs(r.responsibility - 50)
            is_imbalanced = responsibility_diff >= 30
            
            # Check burden level
            is_high_burden = r.burden >= 4
            
            # Check fairness perception
            is_low_fairness = r.fairness <= 3
            
            # Flag different combinations
            if is_imbalanced:
                reasons.append("One partner handles most of this")
            
            if is_high_burden:
                reasons.append("This feels particularly draining")
            
            if is_low_fairness:
                reasons.append("This doesn't feel fair to one or both partners")
            
            # NEW: Special flag for imbalance + unfairness combo
            if is_imbalanced and is_low_fairness:
                reasons.append("PRIORITY: Imbalanced AND feels unfair")
            
            # If any reasons flagged, add to hotspots
            if reasons:
                out.append({
                    "task": r.task.name,
                    "task_id": r.task.id,
                    "pillar": r.task.pillar,
                    "reasons": " | ".join(reasons),
                    "responsibility": r.responsibility,
                    "burden": r.burden,
                    "fairness": r.fairness,
                    # Add priority score for sorting
                    "priority": (
                        (responsibility_diff if is_imbalanced else 0) +
                        (r.burden * 10 if is_high_burden else 0) +
                        ((6 - r.fairness) * 15 if is_low_fairness else 0)
                    )
                })
        
        # Sort by priority (highest first)
        out.sort(key=lambda x: x.get("priority", 0), reverse=True)
        
        return out


# ==================================================
# HELPER FUNCTION - Convert reasons to questions
# ==================================================
def hotspot_to_question(reason: str) -> str:
    """
    Convert a hotspot reason into a conversation-starting question.
    """
    if not reason:
        return "What's one small thing that might make this easier?"
    
    r_lower = reason.lower()
    
    # Priority combo
    if "priority" in r_lower and "imbalanced" in r_lower and "unfair" in r_lower:
        return "This feels both imbalanced and unfair. What would need to change for it to feel better?"
    
    # Imbalance
    if "imbalance" in r_lower or "handling most" in r_lower:
        return "How did this pattern develop? Would a different split work better?"
    
    # High burden
    if "draining" in r_lower or "burden" in r_lower:
        return "What makes this feel so heavy? Is it the task itself or the mental energy around it?"
    
    # Fairness
    if "fair" in r_lower:
        return "What would make this feel fairer to both of you?"
    
    # Default
    return "What's one small thing that might make this easier?"
----
models.py
from pydantic import BaseModel

# models.py (excerpt)
from dataclasses import dataclass, field
from typing import List, Optional

@dataclass
class Task:
    id: str
    name: str
    category: str = "household"
    pillar: str = "identification"    # or anticipation/decision/monitoring/emotional
    requires_children: bool = False
    requires_employment: bool = False
    requires_pets: bool = False  
    requires_vehicle: bool = False  

    # (all optional):
    definition: Optional[str] = None
    what_counts: Optional[List[str]] = field(default_factory=list)
    note: Optional[str] = None
    example: Optional[str] = None

class Response(BaseModel):
    task: Task
    responsibility: int          # 0..100 (0=A, 100=B)
    burden: int                  # 1..5
    fairness: int                # 1..5
    not_applicable: bool = False

----
requirements.txt
streamlit>=1.31
pydantic>=2.7
plotly>=5.24
pandas>=2.2

----
screens/__init__.py

----
screens/consent.py
import streamlit as st

def screen_consent():
    """Streamlined consent following layered information model - key info only"""
    
    # Clear, friendly header
    st.markdown("""
    <div style='text-align: center; margin-bottom: 30px;'>
        <h1 style='font-size: 2.2rem; font-weight: 700; margin-bottom: 8px;'>Quick agreement</h1>
        <p style='font-size: 1.1rem; color: #64748b;'>Two things to know before starting</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Two-column key info - SCANNABLE
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        <div style='background: #f0fdf4; border: 2px solid #86efac; border-radius: 12px; padding: 20px; height: 100%;'>
            <h3 style='font-size: 1rem; margin-bottom: 12px; color: #166534;'>✅ What you'll do</h3>
            <ul style='margin: 0; padding-left: 20px; color: #334155; font-size: 0.95rem;'>
                <li style='margin-bottom: 6px;'><strong>10-15 minutes</strong> answering together</li>
                <li style='margin-bottom: 6px;'><strong>5-page results</strong> to discuss</li>
                <li style='margin-bottom: 0;'><strong>One experiment</strong> to agree on</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='background: #fffbeb; border: 2px solid #fde047; border-radius: 12px; padding: 20px; height: 100%;'>
            <h3 style='font-size: 1rem; margin-bottom: 12px; color: #854d0e;'>🔒 Your data</h3>
            <ul style='margin: 0; padding-left: 20px; color: #334155; font-size: 0.95rem;'>
                <li style='margin-bottom: 6px;'>Stays in <strong>your browser only</strong></li>
                <li style='margin-bottom: 6px;'><strong>Nothing sent</strong> to any server</li>
                <li style='margin-bottom: 0;'><strong>Gone</strong> when you close the tab</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 30px 0 20px;'></div>", unsafe_allow_html=True)
    
    # Safety note - PROMINENT
    st.warning("""
    ⏸️ **This is for constructive conversations, not blame or therapy.** Pause if either of you feels upset. You can stop anytime.
    """)
    
    st.markdown("<div style='margin: 25px 0 15px;'></div>", unsafe_allow_html=True)
    
    # Simple agreement checkboxes - MINIMAL
    kind = st.checkbox("**We'll be kind and pause if it gets difficult**", key="consent_kind")
    consent = st.checkbox("**We consent to answer questions and view results together**", key="consent_agree")
    
    st.markdown("<div style='margin: 20px 0;'></div>", unsafe_allow_html=True)
    
    # Optional details in expander - LAYERED INFO
    with st.expander("📋 Full details (optional - click to read more)"):
        st.markdown("""
        ### About this tool
        
        **Purpose:** This is a research tool developed for a Master's thesis at a Danish university. It helps couples visualise household mental load and agree on small experiments.
        
        **What we collect:** Nothing. All data stays in your browser. We don't collect names, emails, or any identifiable information.
        
        **Voluntary participation:** You can stop at any time and close the browser. There's no penalty for stopping.
        
        **Risks:** Minimal. Some couples may find the questions bring up sensitive topics. We recommend doing this when you're both in a good headspace.
        
        **Benefits:** You'll get personalised insights about your household mental load distribution and research-backed conversation prompts.
        
        **Research basis:** Based on academic research by Daminger (2019), Dean et al. (2022), and Barigozzi et al. (2025) on household cognitive labour.
        
        **Questions?** This tool is not a substitute for couples therapy or counselling. If you're experiencing relationship difficulties, please seek professional support.
        
        **Contact:** [Insert your university email here]
        """)
    
    st.markdown("<div style='margin: 30px 0 10px;'></div>", unsafe_allow_html=True)
    
    # Big CTA - SINGLE ACTION
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        disabled = not (kind and consent)
        if st.button("Let's begin →", disabled=disabled, use_container_width=True, type="primary"):
            st.session_state.stage = "setup"
            st.rerun()
        
        if disabled:
            st.caption("✓ Tick both boxes above to continue")
        else:
            st.caption("Ready to start • 15 minutes together")
----
screens/home.py
# screens/home.py
import streamlit as st

def screen_home():
    # Hero section - BIG and clear
    st.markdown("""
    <div style='text-align: center; padding: 60px 20px 40px;'>
        <h1 style='font-size: 3.5rem; font-weight: 800; margin-bottom: 1rem; line-height: 1.1;'>
            You can't share the load<br/>if it's invisible
        </h1>
        <p style='font-size: 1.4rem; color: #64748b; margin-bottom: 2rem; font-weight: 500;'>
            A 20-minute tool to make household mental work visible
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Quick value props (visual cards) - ORIGINAL GRADIENTS
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>📊</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>See the split</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Who's carrying the invisible work?
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>💬</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>Talk it through</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Questions, not accusations
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>🧪</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>Try one change</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Small experiments, not overhauls
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 50px 0 40px;'></div>", unsafe_allow_html=True)
    
    # How it works - PROFESSIONAL VERSION
    st.markdown("""
    <div style='text-align: center; margin-bottom: 30px;'>
        <h2 style='font-size: 2rem; font-weight: 700; margin-bottom: 10px;'>How It Works</h2>
        <p style='font-size: 1.1rem; color: #64748b;'>Three steps, approximately 20 minutes</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Three steps - ORIGINAL CIRCLES
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #3b82f6; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>1</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>Answer Together</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                Rate 20-25 household tasks on responsibility, burden, and fairness
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #8b5cf6; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>2</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>Review Results</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                Navigate through five pages of personalised insights
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #10b981; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>3</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>Provide Feedback</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                Complete a brief survey about your experience
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 60px 0 40px;'></div>", unsafe_allow_html=True)
    
    # NEW: Research context section
    st.markdown("## About This Research")
    st.info("""
    **Study Purpose:** This tool is being developed as part of a Master's thesis to explore 
    whether digital interventions can facilitate productive dialogue about household cognitive labour.
    
    **What We're Testing:** Whether this tool helps couples understand and discuss mental load, 
    not whether it measures or reduces mental load itself.
    
    **Your Role:** By participating, you're helping evaluate the tool's usability and effectiveness.
    """)
    
    st.markdown("<div style='margin: 40px 0;'></div>", unsafe_allow_html=True)
    
    # Key promises - ORIGINAL BOXES
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        <div style='background: #f0fdf4; border: 2px solid #86efac; border-radius: 12px; padding: 25px;'>
            <h3 style='font-size: 1.1rem; margin-bottom: 15px; color: #166534;'>✅ What you'll get</h3>
            <ul style='margin: 0; padding-left: 20px; color: #334155;'>
                <li style='margin-bottom: 8px;'>Clear view of who's carrying what</li>
                <li style='margin-bottom: 8px;'>Research-backed conversation questions</li>
                <li style='margin-bottom: 8px;'>Personalised insights you can export</li>
                <li style='margin-bottom: 0;'>One actionable next step</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='background: #fffbeb; border: 2px solid #fde047; border-radius: 12px; padding: 25px;'>
            <h3 style='font-size: 1.1rem; margin-bottom: 15px; color: #854d0e;'>🔒 Privacy promise</h3>
            <ul style='margin: 0; padding-left: 20px; color: #334155;'>
                <li style='margin-bottom: 8px;'>No account or email required</li>
                <li style='margin-bottom: 8px;'>Data stays in your browser only</li>
                <li style='margin-bottom: 8px;'>Nothing sent to any server</li>
                <li style='margin-bottom: 0;'>Gone when you close the tab</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 60px 0 30px;'></div>", unsafe_allow_html=True)
    
    # NEW: Important notes section
    st.warning("""
    **Please Note:**
    - This is a research tool, not a clinical instrument
    - Not a substitute for couples therapy or counselling
    - Results are based on your subjective perceptions
    - Pause if discussions become difficult
    """)
    
    # Pause warning - ORIGINAL
    st.warning("""
    ⏸️ **Pause if either of you is tired, stressed, or hungry right now.** This works best when you're both in a good headspace.
    """)
    
    st.markdown("<div style='margin: 30px 0;'></div>", unsafe_allow_html=True)
    
    # CTA - BIG button
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        if st.button("Begin Study →", use_container_width=True, type="primary"):
            st.session_state.stage = "consent"
            st.rerun()
        st.caption("20 minutes together • No data stored • Research-based")
    
    st.markdown("<div style='margin: 60px 0 20px;'></div>", unsafe_allow_html=True)
    
    # NEW: Research details and eligibility in expanders
    col1, col2 = st.columns(2)
    
    with col1:
        with st.expander("🎓 Research Information"):
            st.markdown("""
            **Researcher:** Paul Carmody
            **Institution:** University of Northumbria
            **Programme:** Master's in Computer Science with Data Analytics
            **Supervisor:** Dr. Naveed Anwar

            This study has received ethical approval.
            
            **Based on academic research:**
            - Daminger (2019): Cognitive dimensions of household labour
            - Hart & Staveland (1988): NASA-TLX workload assessment
            - Dean et al. (2022): Mental load and emotional labour
            """)
    
    with col2:
        with st.expander("❓ Who Can Participate?"):
            st.markdown("""
            **Inclusion Criteria:**
            - Cohabiting couples (any gender)
            - Both partners present and consenting
            - Able to complete in English
            - Access to computer/tablet
            
            **Not Suitable For:**
            - Couples in crisis
            - Those seeking clinical intervention
            - Single-person households
            """)
----
screens/learnmore.py
import streamlit as st

def screen_learn_more():
    st.header("Learn more — how this works")
    st.write("Plain-English overview of the science and design choices.")
    st.markdown("""
- **What we measure:** visible time and the *invisible* planning/monitoring/emotional work.
- **Why a quick estimate:** enough to surface patterns and start a caring conversation.
- **Fairness & care:** This isn’t a test. It’s a helper to agree small, practical changes.
    """)
    st.info("We’ll publish a methods note with sources as your thesis progresses.")

----
screens/questionnaire.py
# screens/questionnaire.py
import streamlit as st
from typing import Dict, List

from tasks import get_filtered_tasks, group_by_pillar

# --------- Simple pillar headers ---------
PILLAR_INFO: Dict[str, Dict[str, str]] = {
    "anticipation": {
        "emoji": "🔮",
        "title": "Thinking Ahead",
        "description": "Noticing what will be needed soon and planning for it",
        "example": "Remembering the school form is due, noticing you're low on milk, planning meals"
    },
    "identification": {
        "emoji": "👁️",
        "title": "Noticing What Needs Doing",
        "description": "Spotting what needs to happen and defining the tasks",
        "example": "Seeing the bathroom needs cleaning, recognising a child needs new shoes"
    },
    "decision": {
        "emoji": "🤔",
        "title": "Choosing How & When",
        "description": "Making household choices and coordinating schedules",
        "example": "Deciding what to cook, choosing childcare, picking gifts, scheduling appointments"
    },
    "monitoring": {
        "emoji": "📋",
        "title": "Following Up & Tracking",
        "description": "Keeping track of progress and making sure nothing falls through the cracks",
        "example": "Checking if forms got submitted, following up on RSVPs, tracking bill due dates"
    },
    "emotional": {
        "emoji": "💝",
        "title": "The Caring Work",
        "description": "Noticing and responding to feelings, maintaining relationships",
        "example": "Soothing upset children, remembering to call grandma, managing conflicts"
    }
}

PILLAR_ORDER = ["anticipation", "identification", "decision", "monitoring", "emotional"]

def screen_questionnaire():
    """Simple questionnaire - all sections visible, just scroll through"""
    
    # Header
    st.markdown("""
    <div style='text-align: center; margin-bottom: 30px;'>
        <h1 style='font-size: 2rem; font-weight: 700; margin-bottom: 8px;'>Your household tasks</h1>
        <p style='font-size: 1.1rem; color: #64748b;'>Answer these together • Scroll through all sections • Take your time</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Quick instructions
    with st.expander("📖 How to use this questionnaire"):
        st.markdown("""
        **For each task, answer three questions:**
        1. **Who mainly handles this?** (Slider: Partner A ← → Partner B)
        2. **How mentally draining is this?** (1 = light, 5 = very draining)
        3. **Does this feel fair?** (1 = very unfair, 5 = very fair)
        
        **Tips:**
        - If a task doesn't apply to you, tick "Not applicable"
        - Think about the *mental work* (planning, remembering), not just the physical doing
        - Be honest about how things are, not how you wish they were
        - Take breaks if you need to
        """)
    
    st.info("💭 **Remember:** No right or wrong answers. This is about understanding, not blame.")
    st.markdown("---")
    
    # Get filtered tasks
    children = st.session_state.get("children", 0)
    both_employed = st.session_state.get("is_employed_me", True) and st.session_state.get("is_employed_partner", True)
    has_pets = st.session_state.get("has_pets", False)
    has_vehicle = st.session_state.get("has_vehicle", False)
    tasks = get_filtered_tasks(children, both_employed, has_pets, has_vehicle)
    pillars = group_by_pillar(tasks)
    
    # Initialize responses dict
    if "responses_dict" not in st.session_state:
        st.session_state.responses_dict = {}
    
    # Progress at top
    total_tasks = len(tasks)
    completed_tasks = len(st.session_state.responses_dict)
    
    if total_tasks > 0:
        progress_pct = (completed_tasks / total_tasks) * 100
        col1, col2 = st.columns([3, 1])
        with col1:
            st.progress(progress_pct / 100)
        with col2:
            st.caption(f"**{completed_tasks} / {total_tasks}**")
    
    st.markdown("<div style='margin: 30px 0;'></div>", unsafe_allow_html=True)
    
    # Loop through pillars - all visible
    for pillar_key in PILLAR_ORDER:
        if pillar_key not in pillars:
            continue
        
        info = PILLAR_INFO[pillar_key]
        pillar_tasks = pillars[pillar_key]
        
        # Section header - simple and clear
        st.markdown(f"""
        <div style='background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%); 
                    border-left: 5px solid #6366f1; padding: 20px; border-radius: 12px; margin: 40px 0 25px 0;'>
            <h2 style='margin: 0 0 8px 0; font-size: 1.6rem;'>
                {info['emoji']} {info['title']}
            </h2>
            <p style='margin: 0 0 10px 0; color: #475569; font-size: 1.05rem;'>
                {info['description']}
            </p>
            <p style='margin: 0; color: #64748b; font-size: 0.95rem;'>
                <strong>Examples:</strong> {info['example']}
            </p>
        </div>
        """, unsafe_allow_html=True)
        
        # Render each task
        for task in pillar_tasks:
            render_task(task)
            st.markdown("---")
        
        # Optional section notes
        st.markdown("##### 📝 Notes on this section (optional)")
        notes_key = f"notes_{pillar_key}"
        if "notes_by_section" not in st.session_state:
            st.session_state.notes_by_section = {}
        
        st.session_state.notes_by_section[pillar_key] = st.text_area(
            "Section notes",
            value=st.session_state.notes_by_section.get(pillar_key, ""),
            height=70,
            placeholder="Any thoughts or observations about this section...",
            key=notes_key,
            label_visibility="collapsed"
        )
    
    # Convert dict to list for compatibility
    st.session_state.responses = list(st.session_state.responses_dict.values())
    
    # Bottom navigation
    st.markdown("<div style='margin: 50px 0 30px 0;'></div>", unsafe_allow_html=True)
    st.markdown("---")
    
    # Check how many completed
    actual_completed = sum(1 for r in st.session_state.responses_dict.values() 
                          if not r.get("not_applicable", False))
    
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col1:
        if st.button("← Back to setup", use_container_width=True):
            st.session_state.stage = "setup"
            st.rerun()
    
    with col2:
        if actual_completed < 5:
            st.button(
                "See results →", 
                type="primary", 
                disabled=True,
                use_container_width=True
            )
            st.caption(f"⚠️ Please answer at least 5 tasks ({actual_completed}/5)")
        else:
            if st.button("See results →", type="primary", use_container_width=True):
                st.session_state.stage = "results"
                st.rerun()
            st.caption(f"✅ {actual_completed} tasks answered")


def render_task(task):
    """Render a single task with its three questions"""
    
    # Get existing response
    existing = st.session_state.responses_dict.get(task.id, {})
    
    # Task header
    st.markdown(f"### {task.name}")
    
    if task.definition:
        st.caption(task.definition)
    
    # Optional details
    if task.what_counts or task.example:
        with st.expander("💡 What counts?"):
            if task.what_counts:
                for item in task.what_counts:
                    st.write(f"• {item}")
            if task.example:
                st.info(f"**Example:** {task.example}")
    
    # Create columns for main questions and N/A checkbox
    col_main, col_na = st.columns([4, 1])
    
    with col_main:
        # Question 1: Responsibility
        st.markdown("**Who mainly handles this?**")
        responsibility = st.slider(
            "Responsibility",
            min_value=0, 
            max_value=100, 
            value=existing.get("responsibility", 50),
            key=f"{task.id}_resp",
            label_visibility="collapsed"
        )
        
        # Feedback
        if responsibility < 30:
            st.caption("← Mostly Partner A")
        elif responsibility > 70:
            st.caption("Mostly Partner B →")
        else:
            st.caption("↔️ Shared fairly equally")
        
        st.markdown("")
        
        # Question 2: Burden
        st.markdown("**How mentally draining is this?**")
        burden = st.slider(
            "Mental burden",
            min_value=1, 
            max_value=5, 
            value=existing.get("burden", 3),
            key=f"{task.id}_burden",
            format="%d",
            label_visibility="collapsed"
        )
        
        burden_emoji = {1: "😌", 2: "🙂", 3: "😐", 4: "😓", 5: "😰"}
        burden_text = {1: "Very light", 2: "Manageable", 3: "Moderate", 4: "Heavy", 5: "Very draining"}
        st.caption(f"{burden_emoji.get(burden, '')} {burden_text.get(burden, '')}")
        
        st.markdown("")
        
        # Question 3: Fairness
        st.markdown("**Does this feel fair?**")
        fairness = st.slider(
            "Fairness",
            min_value=1, 
            max_value=5, 
            value=existing.get("fairness", 3),
            key=f"{task.id}_fair",
            format="%d",
            label_visibility="collapsed"
        )
        
        fairness_emoji = {1: "😟", 2: "😕", 3: "😐", 4: "🙂", 5: "😊"}
        fairness_text = {1: "Very unfair", 2: "Somewhat unfair", 3: "Neutral", 4: "Mostly fair", 5: "Very fair"}
        st.caption(f"{fairness_emoji.get(fairness, '')} {fairness_text.get(fairness, '')}")
    
    with col_na:
        st.markdown("**N/A?**")
        not_applicable = st.checkbox(
            "Not applicable",
            value=existing.get("not_applicable", False),
            key=f"{task.id}_na",
            label_visibility="collapsed"
        )
    
    # Save response if changed from defaults
    has_changed = (
        existing  # Already exists
        or not_applicable  # N/A checked
        or responsibility != 50  # Moved
        or burden != 3  # Moved
        or fairness != 3  # Moved
    )
    
    if has_changed:
        st.session_state.responses_dict[task.id] = {
            "task_id": task.id,
            "responsibility": responsibility,
            "burden": burden,
            "fairness": fairness,
            "not_applicable": not_applicable,
        }
----
screens/results.py
# screens/results.py
import streamlit as st
import streamlit.components.v1 as components
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List

from state import reset_state
from tasks import TASK_LOOKUP
from models import Response
from logic import Calculator

A_COL = "#0072B2"  # Okabe–Ito blue (Partner A)
B_COL = "#E69F00"  # Okabe–Ito orange (Partner B)
GRID = "rgba(0,0,0,0.08)"

PILLAR_ORDER = ["anticipation", "identification", "decision", "monitoring", "emotional"]
PILLAR_LABELS = {
    "anticipation": "Anticipation",
    "identification": "Identification",
    "decision": "Decision",
    "monitoring": "Monitoring",
    "emotional": "Emotional",
}

# ---------- Scroll to top helper ----------
def scroll_to_top():
    """Force scroll to top using multiple methods for reliability"""
    components.html(
        """
        <script>
            // Method 1: Scroll main content area
            const mainContent = window.parent.document.querySelector('section.main');
            if (mainContent) {
                mainContent.scrollTop = 0;
            }
            
            // Method 2: Scroll body
            window.parent.document.body.scrollTop = 0;
            
            // Method 3: Scroll document element
            window.parent.document.documentElement.scrollTop = 0;
            
            // Method 4: Use scrollTo on window
            window.parent.scrollTo(0, 0);
            
            // Method 5: Use scrollTo with behavior
            window.parent.scrollTo({top: 0, behavior: 'instant'});
        </script>
        """,
        height=0,
    )

# ---------- utils ----------
def _to_response_objects(response_dicts):
    objs = []
    for r in response_dicts:
        task = TASK_LOOKUP.get(r["task_id"])
        if not task:
            continue
        objs.append(
            Response(
                task=task,
                responsibility=int(r["responsibility"]),
                burden=int(r["burden"]),
                fairness=int(r["fairness"]),
                not_applicable=bool(r.get("not_applicable", False)),
            )
        )
    return objs

def _ensure_all_pillars(scores: Dict[str, List[float]]) -> Dict[str, List[float]]:
    """Guarantee all five pillars exist; fill missing with zeros."""
    out = {}
    for k in PILLAR_ORDER:
        out[k] = list(scores.get(k, [0.0, 0.0]))
        if len(out[k]) != 2:
            out[k] = [0.0, 0.0]
    return out

def _plain_reason(raw: str) -> str:
    s = raw or ""
    s = s.replace("Responsibility imbalance (≥30 pts)", "One partner is handling most of this")
    s = s.replace("High burden", "This feels particularly draining")
    s = s.replace("Low perceived fairness", "This doesn't feel fair to one or both partners")
    return s

def _reason_to_question(reasons: str) -> str:
    """Convert a hotspot reason string into a conversation question."""
    if not reasons:
        return "What's one small thing that might make this easier?"
    
    r_lower = reasons.lower()
    
    # Priority combo
    if "priority" in r_lower and "imbalanced" in r_lower and "unfair" in r_lower:
        return "This feels both imbalanced and unfair. What would need to change for it to feel better?"
    
    # Imbalance
    if "imbalance" in r_lower or "handling most" in r_lower:
        return "How did this pattern develop? Would a different split work better?"
    
    # High burden
    if "draining" in r_lower or "burden" in r_lower:
        return "What makes this feel so heavy? Is it the task itself or the mental energy around it?"
    
    # Fairness
    if "fair" in r_lower:
        return "What would make this feel fairer to both of you?"
    
    # Default
    return "What's one small thing that might make this easier?"

def _add_notes_section(page_name: str):
    """Add optional notes section with clear privacy messaging"""
    with st.expander("📝 Add notes from your conversation (optional)"):
        st.info("""
        **Privacy promise:** 
        - These notes are ONLY stored in your browser's temporary session
        - They're included in your CSV export if you download it
        - Nothing is sent to any server or saved anywhere else
        - When you close this browser tab, they're gone forever
        """)
        
        # Initialise notes dict if it doesn't exist
        if "results_notes" not in st.session_state:
            st.session_state.results_notes = {}
        
        # Get existing note for this page
        existing_note = st.session_state.results_notes.get(page_name, "")
        
        note = st.text_area(
            "Your notes:",
            value=existing_note,
            height=120,
            placeholder="Jot down insights, agreements, or things to try...",
            key=f"note_{page_name}",
            help="These notes are only stored temporarily in your browser and included in your export."
        )
        
        # Save note to session state
        st.session_state.results_notes[page_name] = note

# ---------- visuals ----------
def comparison_bars(a_val: int, b_val: int, max_val: int = 100, label_a="Partner A", label_b="Partner B"):
    """Simple horizontal comparison bars"""
    fig = go.Figure()
    
    fig.add_trace(go.Bar(
        y=[label_a, label_b],
        x=[a_val, b_val],
        orientation='h',
        marker=dict(color=[A_COL, B_COL]),
        text=[f"{a_val}", f"{b_val}"],
        textposition='outside',
        textfont=dict(size=20, color='black'),
    ))
    
    fig.update_layout(
        height=150,
        margin=dict(l=120, r=60, t=10, b=10),
        xaxis=dict(range=[0, max_val], showgrid=False, showticklabels=False),
        yaxis=dict(showgrid=False),
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        showlegend=False,
    )
    
    return fig

def pillar_grouped_bar(pillar_scores: Dict[str, List[float]]) -> go.Figure:
    scores = _ensure_all_pillars(pillar_scores)
    rows = []
    for k in PILLAR_ORDER:
        a, b = scores[k]
        rows.append({"Pillar": PILLAR_LABELS[k], "Partner": "A", "Score": a})
        rows.append({"Pillar": PILLAR_LABELS[k], "Partner": "B", "Score": b})
    df = pd.DataFrame(rows)
    df["Pillar"] = pd.Categorical(df["Pillar"], categories=[PILLAR_LABELS[k] for k in PILLAR_ORDER], ordered=True)

    fig = px.bar(
        df.sort_values("Pillar"),
        x="Pillar", y="Score", color="Partner",
        barmode="group", template="simple_white",
        color_discrete_map={"A": A_COL, "B": B_COL},
    )
    fig.update_layout(
        height=300,
        margin=dict(l=10, r=10, t=10, b=10),
        legend=dict(orientation="h", y=1.08, x=0.0),
    )
    fig.update_xaxes(showgrid=False, ticks="")
    fig.update_yaxes(gridcolor=GRID, zeroline=False, title="")
    return fig

# ---------- CSV export ----------
def _export_csv(responses, results, hotspots):
    df = pd.DataFrame(responses)
    csv = df.to_csv(index=False)

    summary = pd.DataFrame(
        {
            "Metric": [
                "Partner A burden (0–100)",
                "Partner B burden (0–100)",
                "Partner A invisible share (%)",
                "Partner B invisible share (%)",
            ],
            "Value": [
                results["my_burden"],
                results["partner_burden"],
                results["my_share_pct"],
                results["partner_share_pct"],
            ],
        }
    )
    csv += "\n\nSUMMARY\n" + summary.to_csv(index=False)

    p = _ensure_all_pillars(results.get("pillar_scores", {}))
    p_rows = [{"Pillar": PILLAR_LABELS[k], "Partner A sum": round(v[0], 2), "Partner B sum": round(v[1], 2)} for k, v in p.items()]
    csv += "\n\nPILLAR BREAKDOWN\n" + pd.DataFrame(p_rows).to_csv(index=False)

    if hotspots:
        hs_rows = [{"Task": h.get("task", ""), "Why it matters": _plain_reason(h.get("reasons", "")), "Question to discuss": _reason_to_question(h.get("reasons", ""))} for h in hotspots]
        csv += "\n\nCONVERSATION STARTERS\n" + pd.DataFrame(hs_rows).to_csv(index=False)

    # Include QUESTIONNAIRE section notes (from when they filled it in)
    questionnaire_notes = st.session_state.get("notes_by_section", {})
    if any(v.strip() for v in questionnaire_notes.values()):
        csv += "\n\nQUESTIONNAIRE SECTION NOTES\n"
        notes_rows = []
        for section, note in questionnaire_notes.items():
            if note.strip():
                notes_rows.append({"Section": section, "Notes": note.strip()})
        if notes_rows:
            csv += pd.DataFrame(notes_rows).to_csv(index=False)

    # Include RESULTS conversation notes (from results pages)
    results_notes = st.session_state.get("results_notes", {})
    if any(v.strip() for v in results_notes.values()):
        csv += "\n\nRESULTS CONVERSATION NOTES\n"
        notes_rows = []
        for page, note in results_notes.items():
            if note.strip():
                notes_rows.append({"Page": page, "Notes": note.strip()})
        if notes_rows:
            csv += pd.DataFrame(notes_rows).to_csv(index=False)

    return csv

# ---------- conversation prep screen ----------
def screen_before_results():
    """Minimal prep before viewing results"""
    st.title("💬 Before You See Your Results")
    st.caption("Quick prep for a productive conversation")
    
    st.markdown("""
    You're about to see data about mental load in your household. This can bring up feelings - 
    that's normal and shows you're both invested.
    """)
    
    st.markdown("---")
    
    # Ground rules - CONDENSED
    st.success("""
    **🤝 Quick ground rules:**
    - **Do:** Listen to understand, acknowledge feelings, take breaks if needed
    - **Don't:** Keep score, interrupt, or try to "win"
    """)
    
    # Key insight - ONE LINE
    st.info("""
    **💡 Research shows:** Feeling heard matters more than perfect equality. Just discussing mental load improves relationships.
    """)
    
    # Pause warning
    st.warning("⏸️ **Pause if** either of you is tired, stressed, or not ready. This can wait.")
    
    st.markdown("---")
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("← Back", use_container_width=True):
            st.session_state.stage = "questionnaire"
            st.rerun()
    with col2:
        if st.button("Show results →", use_container_width=True, type="primary"):
            st.session_state.results_page = 1
            st.session_state.stage = "results_main"
            st.rerun()

# ---------- PAGINATED RESULTS SECTIONS ----------

def _results_page_1_share(results, hotspots):
    """Page 1: The Big Picture - Who's Carrying What"""
    st.title("📊 Your Results: The Big Picture")
    st.caption("💙 Remember: This is about understanding, not blame.")
    st.progress(20)  # 1 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 📚 Context: What Research Shows")
    
    with st.expander("📖 Click to read about mental load patterns in households"):
        st.markdown("""
        Studies of household labour consistently find:
        
        - **Visible vs. Invisible Split:** Even when couples split physical tasks evenly, the invisible work 
          (planning, remembering, coordinating) is often held by one partner
        - **The "Manager-Helper" Dynamic:** One partner acts as the household manager who delegates, 
          while the other helps when asked - but doesn't carry the mental burden of anticipating needs
        - **Gendered Patterns:** In heterosexual couples, research shows women typically carry 2-3x 
          more cognitive labour, regardless of employment status
        - **Why It Matters:** Unacknowledged mental load is strongly linked to resentment, burnout, 
          and relationship dissatisfaction
        - **Good News:** Simply naming and discussing mental load improves outcomes, even before changes are made
        """)
    
    st.markdown("### 🔍 Your Household's Snapshot")
    st.markdown("Here's what your responses show about mental load distribution right now.")
    
    a_share, b_share = results["my_share_pct"], results["partner_share_pct"]
    
    # Share percentages
    st.markdown("**Mental load share (who's carrying the invisible work):**")
    st.plotly_chart(comparison_bars(a_share, b_share, 100, "Partner A", "Partner B"), use_container_width=True)
    
    # Research context for their numbers
    diff = abs(a_share - b_share)
    if diff <= 15:
        st.success("✅ **Your household shows relatively balanced mental load.** Research suggests 60/40 or closer is associated with higher relationship satisfaction.")
    elif diff <= 30:
        st.info("📊 **Your split is common.** About 60% of couples show this pattern. The question is: does it feel sustainable to both of you?")
    else:
        st.warning("📊 **This pattern is common but can lead to burnout.** Research shows splits beyond 70/30 often predict resentment over time - but this is changeable.")
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - Does this percentage match how it *feels* in daily life?
    - What surprises you about this number?
    - What might explain this pattern in your household?
    """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 1: The Big Picture")


def _results_page_2_burden(results):
    """Page 2: How Heavy Does It Feel"""
    st.title("📊 How Heavy Does It Feel?")
    st.caption("💙 Understanding the emotional weight of invisible work")
    st.progress(40)  # 2 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 😰 Personal Burden")
    st.markdown("""
    **Personal burden (0-100):** This isn't about how much time tasks take - it's about how draining 
    the mental work feels.
    
    Research shows mental load burden comes from:
    - Being "on call" mentally even during downtime
    - The invisible work of anticipating others' needs
    - Carrying responsibility without recognition
    """)
    
    a_burden, b_burden = results["my_burden"], results["partner_burden"]
    st.plotly_chart(comparison_bars(a_burden, b_burden, 100, "Partner A", "Partner B"), use_container_width=True)
    
    # Research context
    burden_diff = abs(a_burden - b_burden)
    if burden_diff <= 15:
        st.success("Both partners report similar burden levels - this suggests the mental energy feels fairly distributed.")
    elif burden_diff <= 30:
        heavier = "Partner A" if a_burden > b_burden else "Partner B"
        st.info(f"📊 {heavier} reports feeling more burdened. This is worth exploring - sometimes visible task-sharing doesn't capture invisible stress.")
    else:
        heavier = "Partner A" if a_burden > b_burden else "Partner B"
        st.warning(f"⚠️ {heavier}'s burden score is notably higher. Research links sustained high burden to burnout and relationship strain.")
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - For the person with higher burden: What makes it feel heavy? Is it the tasks themselves, or the mental energy of managing them?
    - For the person with lower burden: Does this surprise you? What might you not be seeing?
    - Are there times of day or week when burden peaks for each of you?
    """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 2: How Heavy Does It Feel")


def _results_page_3_pillars(results):
    """Page 3: The Five Pillars"""
    st.title("📊 Where the Mental Load Lives")
    st.caption("💙 Breaking down the five types of invisible work")
    st.progress(60)  # 3 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 🏛️ The Five Pillars of Mental Load")
    st.markdown("""
    Research identifies five types of cognitive labour in households. This chart shows which 
    partner is carrying more of each type.
    """)
    
    with st.expander("ℹ️ What these five pillars mean (click to expand)"):
        st.markdown("""
        Based on research in household labour and emotional work:
        
        - **Anticipation:** Thinking ahead to what will be needed (meal planning, remembering appointments, 
          anticipating when supplies run low)
        - **Identification:** Noticing what needs doing (seeing the mess, recognising when something's broken, 
          spotting when someone needs support)
        - **Decision-Making:** Researching options and making choices (which doctor, what gift, how to handle 
          a situation)
        - **Monitoring:** Tracking progress and following up (did the form get submitted? Is the kids' project 
          done? Are we running low on groceries?)
        - **Emotional Labour:** Managing feelings, maintaining relationships, providing support, creating 
          household harmony
        
        **Key finding:** The monitoring and anticipation pillars are often most invisible to the partner not doing them.
        """)
    
    pillar_scores = _ensure_all_pillars(results.get("pillar_scores", {}))
    st.plotly_chart(pillar_grouped_bar(pillar_scores), use_container_width=True)
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - Which pillar shows the biggest difference between you?
    - Is there a pillar where one person didn't realise how much the other was doing?
    - Research shows "monitoring" is often invisible - does that resonate?
    """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 3: The Five Pillars")


def _results_page_4_hotspots(hotspots):
    """Page 4: Conversation Starters - REDUCED TO TOP 5 ONLY"""
    st.title("📊 Conversation Starters")
    st.caption("💙 Focus on just a few key topics")
    st.progress(80)  # 4 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 💬 Areas to Explore")
    st.markdown("""
    These aren't "problems to fix" - they're **topics worth exploring together**. 
    
    Research shows that couples who regularly discuss mental load (even without making immediate changes) 
    report higher satisfaction than those who don't talk about it.
    
    **We've focused on just the top few areas** to keep your conversation manageable and productive.
    """)
    
    if hotspots:
        # LIMIT TO TOP 5 MAXIMUM
        top_hotspots = hotspots[:5]
        
        st.info(f"📌 We've identified {len(top_hotspots)} priority {'area' if len(top_hotspots) == 1 else 'areas'} to discuss. Pick one or two to start with.")
        
        # Show all selected hotspots fully expanded
        for i, h in enumerate(top_hotspots, 1):
            with st.container():
                st.markdown(f"### {i}. {h.get('task', 'Task')}")
                
                col1, col2 = st.columns([1, 1])
                with col1:
                    plain = _plain_reason(h.get("reasons", ""))
                    st.markdown(f"**Why it came up:** {plain}")
                
                with col2:
                    question = _reason_to_question(h.get("reasons", ""))
                    st.markdown(f"**💭 Discuss:** {question}")
                
                st.markdown("")
        
        # Note about focusing on just a few
        if len(hotspots) > 5:
            st.info(f"💡 **Note:** There were {len(hotspots)} total areas flagged, but we're showing only the top 5 to help you focus. You can always revisit this tool to explore others later.")
    else:
        st.success("""
        🎉 **No major conversation starters detected!** 
        
        Your responses suggest relatively balanced mental load distribution. This is worth celebrating!
        
        Still, research recommends checking in periodically - life circumstances change, and what works 
        now might need adjustment later.
        """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 4: Conversation Starters")


def _results_page_5_action():
    """Page 5: What's Next"""
    st.title("📊 What's Next")
    st.caption("💙 Building from strengths and trying small experiments")
    st.progress(100)  # 5 of 5 pages
    
    st.markdown("---")
    
    # ====== WHAT'S WORKING ======
    st.markdown("## ✨ What's Working Well")
    st.markdown("""
    Research on couple interventions shows that building from strengths is more effective than 
    only focusing on problems.
    """)
    
    # Find areas of relative balance
    balanced_areas = []
    for task_response in st.session_state.responses:
        resp_diff = abs(task_response.get("responsibility", 50) - 50)
        if resp_diff <= 20 and task_response.get("burden", 50) < 60:
            task = TASK_LOOKUP.get(task_response["task_id"])
            if task:
                balanced_areas.append(task.name)
    
    if balanced_areas:
        st.success(f"**Areas showing good balance:** {', '.join(balanced_areas[:5])}")
        st.markdown("💭 **Discuss:** What makes these areas work well? Can you apply that pattern elsewhere?")
    else:
        st.info("**Every household has strengths.** What's one thing you're both proud of in how you manage your home together?")
    
    st.markdown("---")
    
    # ====== EXPERIMENT ======
    # ====== CRITICAL: SURVEY LINK ======
    st.markdown("## 📋 Essential: Quick Survey")
    st.error("""
    **⚠️ Please complete this 5-minute survey now - it's crucial for the research!**
    
    Your feedback helps us understand if the tool was useful.
    This directly impacts the validity of the thesis research.
    """)
    
    survey_url = "https://forms.office.com/e/jM0DXUg1vV"
    
    col1, col2, col3 = st.columns([1, 3, 1])
    with col2:
        st.link_button(
            "📋 Complete survey now (5 min) →",
            survey_url,
            use_container_width=True,
            type="primary"
        )
        st.caption("⭐ Essential for research • Completely anonymous")
    
    st.markdown("---")
    
    # Done
    st.success("""
    **🎉 You've completed the tool!**
    
    **Next steps:**
    1. ✅ Complete the survey above
    2. 📥 Download your results if you want a copy(button at top)
    3. 🧪 Try your one-week experiment
    4. 🔄 Check in next week
    """)
    
    st.markdown("---")
    _add_notes_section("Page 5: Action Plan")


# ---------- main results navigation ----------
def screen_results_main():
    """Main results with pagination"""
    
    if not st.session_state.get("responses"):
        st.warning("No results yet. Please complete the questionnaire first.")
        return

    # compute results once
    response_objs = _to_response_objects(st.session_state.responses)
    calc = Calculator(response_objs)
    results = calc.compute()
    hotspots = Calculator.detect_hotspots(response_objs)

    # Initialise page if not set
    if "results_page" not in st.session_state:
        st.session_state.results_page = 1
    
    current_page = st.session_state.results_page
    
    # TOP NAVIGATION - So users don't need to scroll
    col1, col2, col3, col4 = st.columns([1, 1, 1, 1])
    with col1:
        if current_page > 1:
            if st.button("← Previous", key="top_prev", use_container_width=True):
                st.session_state.results_page -= 1
                st.rerun()
        else:
            st.button("← Previous", key="top_prev_disabled", disabled=True, use_container_width=True)
    with col2:
        if current_page < 5:
            if st.button("Next →", key="top_next", use_container_width=True, type="primary"):
                st.session_state.results_page += 1
                st.rerun()
        else:
            if st.button("🏠 Finish", key="top_finish", use_container_width=True, type="primary"):
                st.session_state.stage = "home"
                st.rerun()
    
    with col4:
        csv_data = _export_csv(st.session_state.responses, results, hotspots)
        st.download_button(
            "📥 Export",
            data=csv_data,
            file_name="mental_load_results.csv",
            mime="text/csv",
            use_container_width=True,
            key="top_export"
        )
    
    st.caption(f"Page {current_page} of 5")
    st.markdown("---")
    
    # Render current page
    if current_page == 1:
        _results_page_1_share(results, hotspots)
    elif current_page == 2:
        _results_page_2_burden(results)
    elif current_page == 3:
        _results_page_3_pillars(results)
    elif current_page == 4:
        _results_page_4_hotspots(hotspots)
    elif current_page == 5:
        _results_page_5_action()
    
    # Show note count if any notes exist (both questionnaire AND results notes)
    questionnaire_notes = st.session_state.get("notes_by_section", {})
    results_notes = st.session_state.get("results_notes", {})
    questionnaire_note_count = sum(1 for v in questionnaire_notes.values() if v.strip())
    results_note_count = sum(1 for v in results_notes.values() if v.strip())
    total_note_count = questionnaire_note_count + results_note_count
    
    if total_note_count > 0:
        st.info(f"📝 You have notes on {total_note_count} page(s) ({questionnaire_note_count} from questionnaire, {results_note_count} from results) - they'll be included in your export")
    
    # Page indicators at bottom
    st.markdown("---")
    dots = ""
    for i in range(1, 6):
        if i == current_page:
            dots += "🔵 "
        else:
            dots += "⚪ "
    st.markdown(f"<div style='text-align: center; padding: 8px;'>{dots}</div>", unsafe_allow_html=True)
    
    st.caption("""
    💙 **Remember:** This is one snapshot in time. Mental load shifts with life circumstances. 
    The healthiest couples check in regularly, not just once.
    """)


# ---------- Main entry point ----------
def screen_results():
    """Route to either prep screen or main results"""
    # First time seeing results? Show prep screen
    if not st.session_state.get("results_prep_seen", False):
        st.session_state.results_prep_seen = True
        screen_before_results()
    else:
        screen_results_main()
----
screens/setup.py
import streamlit as st
from tasks import get_filtered_tasks

def screen_setup():
    """Clean setup page with better layout"""
    
    st.markdown("""
    <div style='text-align: center; margin-bottom: 25px;'>
        <h1 style='font-size: 2rem; font-weight: 700; margin-bottom: 8px;'>Quick setup</h1>
        <p style='font-size: 1rem; color: #64748b;'>Tell us about your household so we show relevant tasks</p>
    </div>
    """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 30px 0 20px;'></div>", unsafe_allow_html=True)
    
    # SECTION 1: Children
    st.markdown("### 👨‍👩‍👧‍👦 Children")
    children = st.number_input(
        "How many children live in your household?", 
        min_value=0, 
        max_value=10, 
        step=1, 
        value=st.session_state.get("children", 0),
        help="We'll show child-related tasks if you have children"
    )
    st.session_state.children = children
    
    st.markdown("<div style='margin: 25px 0;'></div>", unsafe_allow_html=True)
    
    # SECTION 2: Employment (side by side)
    st.markdown("### 💼 Employment")
    col1, col2 = st.columns(2)
    
    with col1:
        is_employed_me = st.checkbox(
            "Partner A employed?",
            value=st.session_state.get("is_employed_me", True),
            help="Tick if Partner A has paid employment"
        )
        st.session_state.is_employed_me = is_employed_me
    
    with col2:
        is_employed_partner = st.checkbox(
            "Partner B employed?",
            value=st.session_state.get("is_employed_partner", True),
            help="Tick if Partner B has paid employment"
        )
        st.session_state.is_employed_partner = is_employed_partner
    
    st.markdown("<div style='margin: 25px 0;'></div>", unsafe_allow_html=True)
    
    # SECTION 3: Pets and Vehicle (side by side)
    st.markdown("### 🐾 Pets & 🚗 Vehicle")
    col1, col2 = st.columns(2)
    
    with col1:
        has_pets = st.checkbox(
            "Do you have pets?",
            value=st.session_state.get("has_pets", False),
            help="We'll include pet care tasks"
        )
        st.session_state.has_pets = has_pets
    
    with col2:
        has_vehicle = st.checkbox(
            "Do you have a car/vehicle?",
            value=st.session_state.get("has_vehicle", False),
            help="We'll include vehicle maintenance tasks"
        )
        st.session_state.has_vehicle = has_vehicle
    
    st.markdown("<div style='margin: 30px 0 20px;'></div>", unsafe_allow_html=True)
    
    # Show task count - SIMPLER MESSAGE
    both_employed = is_employed_me and is_employed_partner
    filtered = get_filtered_tasks(children, both_employed, has_pets, has_vehicle)
    
    st.success(f"✅ **{len(filtered)} tasks** selected based on your answers")
    
    st.markdown("<div style='margin: 25px 0;'></div>", unsafe_allow_html=True)
    
    # Navigation
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col1:
        if st.button("← Back", use_container_width=True):
            st.session_state.stage = "consent"
            st.rerun()
    
    with col2:
        if st.button("Start questionnaire →", type="primary", use_container_width=True):
            # Reset questionnaire state
            st.session_state.responses_dict = {}
            st.session_state.responses = []
            st.session_state.notes_by_section = {}
            st.session_state.stage = "questionnaire"
            st.rerun()
----
state.py
import streamlit as st

def init_state():
    defaults = dict(
        stage="home",
        # setup
        household_type="couple",
        children=0,
        is_employed_me=True,
        is_employed_partner=True,
        has_pets=False, 
        has_vehicle=False, 
        # questionnaire progress
        q_section_index=0,
        q_task_index=0,
        responses=[],
        notes_by_section={},
        questionnaire_start_time=None,
    )
    for k,v in defaults.items():
        if k not in st.session_state:
            st.session_state[k] = v

def reset_state():
    keys = list(st.session_state.keys())
    for k in keys:
        del st.session_state[k]
    init_state()

----
streamlit/config.toml
[theme]
base="light"
primaryColor="#3b82f6"
backgroundColor="#ffffff"
secondaryBackgroundColor="#f8fafc"
textColor="#0f172a"
font="sans serif"
----
tasks.py
"""
tasks.py

This module defines the full list of household tasks used by the Mental Load Helper.
I've expanded and annotated the task catalogue so it can be filtered by household
context (children, pets, vehicles, employment status) and grouped by pillar.

Do not change task IDs casually — they're used as stable keys in session state and
CSV exports.
"""

from typing import List, Dict
from models import Task

TASKS: list[Task] = [
    # Anticipation pillar — tasks that involve planning and thinking ahead
    
    Task(
        id="meal_planning",
        name="Meal planning & grocery list",
        pillar="anticipation",
        definition=(
            "By meal planning & prep we mean the *whole* flow — not just cooking, "
            "but deciding what to eat, checking what's low, building the list, and "
            "sequencing the week so food actually happens."
        ),
        what_counts=[
            "Noticing what's low / planning the week's meals",
            "Creating or updating the grocery list / booking delivery/pick-up",
            "Remembering dietary needs, timings, after-school or late-work days",
            "Prepping ahead (marinating, batch cooking) so the week runs",
        ],
        note="Answer for the 'invisible' work here (planning/organising); the cooking task itself is separate.",
        example="If one partner mostly plans and manages the list, set Responsibility nearer their side (e.g., 70–90).",
    ),
    
    Task(
        id="household_supplies",
        name="Household supplies & consumables",
        pillar="anticipation",
        definition=(
            "Noticing when household items are running low and ensuring they're restocked before you run out."
        ),
        what_counts=[
            "Tracking toilet paper, cleaning products, toiletries",
            "Noticing when bins need new bags, dishwasher needs tablets",
            "Ordering or buying replacements before they run out",
            "Remembering what brands/types each person prefers",
        ],
        example="If one partner notices and orders everything, Responsibility ~80-100 to them.",
    ),
    
    Task(
    id="holiday_planning",
    name="Holiday & vacation planning",
    pillar="anticipation",
    definition=(
        "Planning family holidays and vacations - researching, booking, and coordinating all the details."
    ),
    what_counts=[
        "Researching holiday destinations and accommodation",
        "Booking flights, hotels, activities",
        "Planning itineraries and packing lists",
        "Coordinating time off work and school holidays",
        "Managing travel documents (passports, visas, insurance)",
    ],
    example="If one partner does most of the holiday research and booking, Responsibility ~80-100.",
),

    
    Task(
        id="birthday_gifts",
        name="Gifts, cards & social obligations",
        pillar="anticipation",
        definition=(
            "Remembering birthdays, anniversaries, and social occasions, and organising cards, gifts, or RSVPs."
        ),
        what_counts=[
            "Remembering family/friends' birthdays and important dates",
            "Choosing, buying, wrapping gifts",
            "Sending cards or organising celebrations",
            "Tracking RSVPs and social commitments",
        ],
        example="If one partner manages the family calendar of social obligations, Responsibility ~70-100.",
    ),
    
    Task(
        id="seasonal_prep",
        name="Seasonal & future planning",
        pillar="anticipation",
        definition=(
            "Thinking ahead to seasonal needs, holidays, and future household requirements."
        ),
        what_counts=[
            "Planning for holidays, school breaks, seasons changing",
            "Preparing for birthdays, Christmas, summer holidays",
            "Anticipating when kids need new clothes/shoes/school supplies",
            "Thinking ahead about home repairs or maintenance",
        ],
        example="If one partner does most of the forward-thinking, Responsibility ~70-90.",
    ),
    
    # Identification pillar — visible tasks and noticing what needs doing
    
    Task(
        id="cooking",
        name="Cooking (the visible bit)",
        pillar="identification",
        definition=(
            "This is the *doing* part — cooking the meals. It doesn't include deciding "
            "what to cook or building the shopping list (covered in Meal planning)."
        ),
        what_counts=[
            "Cooking on weekdays/weekends",
            "Warming/prepping for kids or different mealtimes",
            "Tidying as you go (if part of your norm)",
        ],
        note="If you alternate days, that's shared — use ~50.",
        example="If one partner cooks most weeknights, Responsibility might sit ~70–80.",
    ),
    
    Task(
        id="cleaning",
        name="Cleaning (routine)",
        pillar="identification",
        definition=(
            "Regular cleaning tasks and the *system* behind them (not occasional deep cleans unless that's your norm)."
        ),
        what_counts=[
            "Weekly surfaces, bathrooms, floors",
            "Small resets (dishes, counters, bins)",
            "Remembering consumables (sponges, sprays, bags)",
            "A loose rota/checklist if you use one",
        ],
        note="If one person sets the standard and nudges others, that's part of the load.",
        example="If you split weekends but one partner owns the standard, Responsibility ~60–70 to them.",
    ),
    
    Task(
        id="tidying",
        name="Tidying & decluttering",
        pillar="identification",
        definition=(
            "Noticing mess, clutter, and items out of place, and putting things back where they belong."
        ),
        what_counts=[
            "Picking up clothes, toys, items left around",
            "Putting things back in their proper places",
            "Decluttering surfaces and common areas",
            "Organising storage and cupboards",
        ],
        example="If one partner is constantly tidying up after everyone, Responsibility ~70-100.",
    ),
    
    Task(
        id="laundry",
        name="Laundry flow",
        pillar="identification",
        definition=(
            "Everything from noticing the hamper's full to finishing clean clothes in drawers. "
            "We're focusing on the *flow ownership* (who keeps it moving) rather than who folds once."
        ),
        what_counts=[
            "Noticing when to run loads; sorting/whites/darks",
            "Keeping machines cycling; moving wet clothes promptly",
            "Folding/hanging; putting away or delegating it",
            "Remembering school kits/sports days/uniforms",
        ],
        note="If one partner 'keeps it spinning' even if others help sometimes, weight toward that person.",
        example="If A notices and runs everything and B folds occasionally, Responsibility ~70–90 to A.",
    ),
    
    Task(
        id="home_maintenance",
        name="Home repairs & maintenance",
        pillar="identification",
        definition=(
            "Noticing when things break or need maintenance, and organising repairs or fixes."
        ),
        what_counts=[
            "Spotting broken items, leaks, things that need fixing",
            "Calling repair people, getting quotes",
            "Scheduling and coordinating home maintenance",
            "DIY repairs or organising someone to do them",
        ],
        example="If one partner notices and coordinates all repairs, Responsibility ~80-100.",
    ),
    Task(
    id="pet_care",
    name="Pet care & management",
    pillar="identification",
    requires_pets=True,  # conditional flag: only include when household has pets
    definition=(
        "Daily pet care and the mental load of remembering vet appointments, food, medication, and pet needs."
    ),
    what_counts=[
        "Feeding, walking, grooming pets",
        "Remembering vet appointments and vaccinations",
        "Noticing when pet food or supplies are running low",
        "Coordinating pet care when away from home",
        "Managing pet health issues and medication",
    ],
    example="If one partner manages all pet schedules and needs, Responsibility ~80-100.",
),
    # Decision pillar — tasks that require choosing, organising or deciding
    
    Task(
        id="bills_admin",
        name="Bills & admin",
        pillar="decision",
        definition=(
            "Staying on top of finances and life admin so things don't lapse or get stressful."
        ),
        what_counts=[
            "Paying rent/mortgage, utilities, subscriptions",
            "Switching providers, renewals, comparisons",
            "Budgeting, expense tracking, filing receipts",
            "Chasing missing refunds/claims",
        ],
        note="Think 'headspace ownership' — who ensures this stays under control?",
        example="If one partner runs the calendar, reminders and switches, Responsibility ~70–100.",
    ),
    
    Task(
        id="appointments_health",
        name="Appointments & health",
        pillar="decision",
        definition=(
            "Booking, tracking and following up on healthcare or essential appointments for the household."
        ),
        what_counts=[
            "Booking GP/dentist/optician; tracking reminders",
            "Booking car service/repairs if you own one",
            "Following up on results, prescriptions, referrals",
            "Keeping the household calendar up to date",
        ],
        note="If one person handles most of the coordination, weight toward them.",
        example="If A books and tracks most appointments, Responsibility ~70–90.",
    ),
    
    Task(
        id="social_calendar",
        name="Social calendar & coordination",
        pillar="decision",
        definition=(
            "Managing the household's social life, coordinating schedules, and making social plans."
        ),
        what_counts=[
            "Coordinating family/couple social plans",
            "Managing conflicting schedules between household members",
            "Deciding on weekend plans or activities",
            "Organising when to see friends and family",
        ],
        example="If one partner coordinates most social planning, Responsibility ~70-90.",
    ),
    
    Task(
        id="kids_activities",
        name="Children's activities & hobbies",
        pillar="decision",
        requires_children=True,
        definition=(
            "Researching, choosing, and enrolling children in activities, hobbies, and clubs."
        ),
        what_counts=[
            "Researching options for activities/clubs/sports",
            "Deciding what children should participate in",
            "Enrolling and managing registrations",
            "Coordinating schedules and transport",
        ],
        example="If one partner researches and enrolls children in activities, Responsibility ~80-100.",
    ),
    Task(
    id="tech_troubleshooting",
    name="Tech support & troubleshooting",
    pillar="decision",
    definition=(
        "Being the household tech support - fixing issues, managing devices, and keeping digital life running."
    ),
    what_counts=[
        "Fixing wifi/computer/phone problems",
        "Managing subscriptions and accounts (Netflix, utilities apps, etc.)",
        "Setting up new devices and software",
        "Troubleshooting when tech doesn't work",
        "Managing passwords, security, backups",
        "Being the person everyone asks when tech breaks",
    ],
    note="This is executive function work - requires problem-solving and staying calm under pressure.",
    example="If one partner is the default tech troubleshooter, Responsibility ~70-100.",
),
    # Monitoring pillar — keeping track, following up, and coordinating
    
    Task(
        id="kids_school",
        name="Children: school & schoolwork",
        pillar="monitoring",
        requires_children=True,
        definition=(
            "The orchestration behind school life — not the single pickup, but who keeps the whole system moving."
        ),
        what_counts=[
            "Remembering non-uniform days, forms, trips, fees",
            "Tracking homework and school projects",
            "Parent-teacher communication, emails, portals",
            "Monitoring children's academic progress",
        ],
        note="If you don't have children, this won't show.",
        example="If one partner is the default 'school admin', Responsibility tends to be high (e.g., 80–100).",
    ),
    
    Task(
        id="kids_health",
        name="Children's health & development",
        pillar="monitoring",
        requires_children=True,
        definition=(
            "Tracking children's health, development milestones, and medical needs."
        ),
        what_counts=[
            "Booking and attending children's health appointments",
            "Tracking vaccinations and health records",
            "Monitoring developmental milestones",
            "Noticing if children seem unwell or struggling",
        ],
        example="If one partner monitors and coordinates children's health, Responsibility ~80-100.",
    ),
    
    Task(
        id="household_calendar",
        name="Household calendar & coordination",
        pillar="monitoring",
        definition=(
            "Being the keeper of the family schedule and ensuring everyone knows where they need to be."
        ),
        what_counts=[
            "Maintaining the shared calendar",
            "Reminding others about upcoming appointments/events",
            "Coordinating who's picking up kids, who's cooking, etc.",
            "Ensuring conflicting commitments are resolved",
        ],
        example="If one partner is the 'calendar keeper', Responsibility ~80-100.",
    ),
    
    Task(
        id="food_waste",
        name="Food waste & leftovers",
        pillar="monitoring",
        definition=(
            "Tracking what food is in the fridge, using up leftovers, and preventing waste."
        ),
        what_counts=[
            "Checking what's in the fridge before it goes off",
            "Planning meals around leftovers",
            "Remembering to use ingredients before they expire",
            "Managing food storage and organisation",
        ],
        example="If one partner always knows what's in the fridge, Responsibility ~70-90.",
    ),
    
    Task(
        id="work_life_coordination",
        name="Work-life coordination",
        pillar="monitoring",
        requires_employment=True,
        definition=(
            "Managing the household around work schedules and coordinating when conflicts arise."
        ),
        what_counts=[
            "Tracking both partners' work schedules",
            "Adjusting household plans around work commitments",
            "Coordinating childcare/pickups when work runs late",
            "Managing household when one partner travels for work",
        ],
        example="If one partner does most of the 'work schedule tetris', Responsibility ~70-90.",
    ),
    Task(
    id="vehicle_maintenance",
    name="Car/vehicle maintenance",
    pillar="monitoring",
    requires_vehicle=True,  # conditional flag: only include when household has a vehicle
    definition=(
        "Tracking car servicing, MOT, insurance, and ensuring the vehicle stays roadworthy."
    ),
    what_counts=[
        "Remembering MOT and service due dates",
        "Booking and arranging car maintenance",
        "Managing car insurance renewals",
        "Noticing when car needs attention (tyres, fluids, issues)",
        "Coordinating repairs and dealing with mechanics",
    ],
    example="If one partner tracks and arranges all vehicle maintenance, Responsibility ~80-100.",
),

    # Emotional pillar — the emotional and relational work that keeps a home well
    
    Task(
        id="kids_emotional",
        name="Children's emotional wellbeing",
        pillar="emotional",
        requires_children=True,
        definition=(
            "Noticing and responding to children's emotional needs, worries, and struggles."
        ),
        what_counts=[
            "Checking in with children about their feelings",
            "Noticing when children seem upset or struggling",
            "Providing emotional support and reassurance",
            "Managing bedtime routines, soothing upsets",
        ],
        example="If one partner does most emotional check-ins, Responsibility ~80-100.",
    ),
    
    Task(
        id="relationship_maintenance",
        name="Relationship maintenance",
        pillar="emotional",
        definition=(
            "The work of maintaining your relationship - planning couple time, checking in emotionally."
        ),
        what_counts=[
            "Suggesting date nights or couple time",
            "Initiating conversations about the relationship",
            "Noticing when the relationship needs attention",
            "Remembering anniversaries and special occasions",
        ],
        example="If one partner usually suggests couple time, Responsibility ~70-90.",
    ),
    
    Task(
        id="family_relationships",
        name="Extended family relationships",
        pillar="emotional",
        definition=(
            "Managing relationships with extended family - remembering to call, organising visits, managing expectations."
        ),
        what_counts=[
            "Remembering to call/message parents, in-laws, relatives",
            "Organising family visits and gatherings",
            "Managing family expectations and conflicts",
            "Keeping family members updated on household news",
        ],
        example="If one partner manages most family communications, Responsibility ~80-100.",
    ),
    
    Task(
        id="household_mood",
        name="Household mood & atmosphere",
        pillar="emotional",
        definition=(
            "Managing the emotional atmosphere of the home - smoothing conflicts, creating positive moments."
        ),
        what_counts=[
            "Noticing when household tension is high",
            "Mediating conflicts between household members",
            "Creating positive moments (family activities, treats)",
            "Being the 'emotional thermostat' of the home",
        ],
        example="If one partner is the emotional manager, Responsibility ~80-100.",
    ),
    
    Task(
        id="partner_support",
        name="Partner emotional support",
        pillar="emotional",
        definition=(
            "Providing emotional support to your partner - listening, remembering their needs, checking in."
        ),
        what_counts=[
            "Remembering what's stressing your partner",
            "Asking how their day/work/life is going",
            "Providing emotional support and encouragement",
            "Noticing when your partner needs extra support",
        ],
        example="If one partner does most emotional checking-in, Responsibility ~70-90.",
    ),
]


TASK_LOOKUP: Dict[str, Task] = {t.id: t for t in TASKS}

def get_filtered_tasks(children: int, both_employed: bool, has_pets: bool, has_vehicle: bool) -> List[Task]:
    """
    Filter tasks based on household context.
    
    Args:
        children: Number of children
        both_employed: Whether both partners are employed
        has_pets: Whether household has pets
        has_vehicle: Whether household has a car/vehicle
    """
    out: List[Task] = []
    for t in TASKS:
        # Skip child-related tasks if no children
        if t.requires_children and children <= 0:
            continue
        # Skip employment tasks if not both employed
        if t.requires_employment and not both_employed:
            continue
        # Skip pet tasks if no pets
        if t.requires_pets and not has_pets:
            continue
        # Skip vehicle tasks if no vehicle
        if t.requires_vehicle and not has_vehicle:
            continue
        out.append(t)
    return out


def group_by_pillar(tasks: List[Task]) -> Dict[str, List[Task]]:
    d: Dict[str, List[Task]] = {}
    for t in tasks:
        d.setdefault(t.pillar, []).append(t)
    return d
----
utils/__init__.py

----
utils/dev_mode.py
# utils/dev_mode.py
import random
import streamlit as st
from tasks import get_filtered_tasks

def is_dev_mode():
    """Check if dev mode is enabled"""
    return st.session_state.get("dev_mode", False)

def toggle_dev_mode():
    """Toggle dev mode on/off"""
    st.session_state.dev_mode = not st.session_state.get("dev_mode", False)

def generate_sample_responses(scenario="balanced"):
    """
    Generate sample responses for testing
    
    Scenarios:
    - "balanced": Fairly even split (45-55 range)
    - "imbalanced": One partner carries most (70-90 range)
    - "mixed": Mix of balanced and imbalanced tasks
    - "random": Completely random
    """
    children = st.session_state.get("children", 0)
    both_employed = st.session_state.get("is_employed_me", True) and st.session_state.get("is_employed_partner", True)
    
    tasks = get_filtered_tasks(children, both_employed)
    responses = []
    
    for task in tasks:
        if scenario == "balanced":
            # Fairly balanced household
            responsibility = random.randint(40, 60)
            burden = random.randint(2, 4)
            fairness = random.randint(3, 5)
            
        elif scenario == "imbalanced":
            # Partner A carries most of the load
            responsibility = random.randint(10, 35)  # Partner A doing most
            burden = random.randint(3, 5)  # Higher burden
            fairness = random.randint(1, 3)  # Lower fairness
            
        elif scenario == "mixed":
            # Some balanced, some not
            if random.random() < 0.3:  # 30% imbalanced
                responsibility = random.choice([random.randint(10, 30), random.randint(70, 90)])
                burden = random.randint(3, 5)
                fairness = random.randint(2, 4)
            else:  # 70% balanced
                responsibility = random.randint(40, 60)
                burden = random.randint(2, 4)
                fairness = random.randint(3, 5)
                
        else:  # random
            responsibility = random.randint(0, 100)
            burden = random.randint(1, 5)
            fairness = random.randint(1, 5)
        
        responses.append({
            "task_id": task.id,
            "responsibility": responsibility,
            "burden": burden,
            "fairness": fairness,
            "not_applicable": False,
        })
    
    return responses

def populate_dev_data(scenario="balanced"):
    """Populate session state with dev data"""
    st.session_state.responses = generate_sample_responses(scenario)
    st.session_state.notes_by_section = {
        "anticipation": "Dev mode note: This section felt heavy",
        "emotional": "Dev mode note: Lots to discuss here",
    }
    st.success(f"✅ Dev mode: Populated {len(st.session_state.responses)} tasks with '{scenario}' scenario")

def dev_mode_widget():
    """Display dev mode controls in sidebar"""
    if not is_dev_mode():
        return
    
    st.sidebar.markdown("---")
    st.sidebar.markdown("### 🛠️ Dev Mode")
    
    col1, col2 = st.sidebar.columns(2)
    
    with col1:
        if st.sidebar.button("Balanced", use_container_width=True):
            populate_dev_data("balanced")
            st.rerun()
    
    with col2:
        if st.sidebar.button("Imbalanced", use_container_width=True):
            populate_dev_data("imbalanced")
            st.rerun()
    
    col3, col4 = st.sidebar.columns(2)
    
    with col3:
        if st.sidebar.button("Mixed", use_container_width=True):
            populate_dev_data("mixed")
            st.rerun()
    
    with col4:
        if st.sidebar.button("Random", use_container_width=True):
            populate_dev_data("random")
            st.rerun()
    
    if st.sidebar.button("Clear All Data", use_container_width=True):
        st.session_state.responses = []
        st.session_state.notes_by_section = {}
        st.success("✅ Cleared all data")
        st.rerun()
    
    st.sidebar.caption(f"📊 {len(st.session_state.get('responses', []))} tasks populated")
----
utils/ui.py
# utils/ui.py
import html
import streamlit as st
import streamlit.components.v1 as components
from typing import List, Optional

def _has_popover() -> bool:
    return hasattr(st, "popover")

def _esc(s: str) -> str:
    # Escape HTML so user text doesn’t break your markup
    return html.escape(s or "")

def step_header(title: str, subtitle: str = "", progress: int | None = None):
    st.markdown(f"### {title}")
    if subtitle:
        st.caption(subtitle)
    if isinstance(progress, int):
        st.progress(max(0, min(progress, 100)))

def learn_popover():
    ctx = st.popover("🔎 Learn / Help") if _has_popover() else st.expander("🔎 Learn / Help")
    with ctx:
        st.markdown("**What is mental load?**")
        st.write("The unseen planning, thinking and keeping-track work behind household life.")
        st.markdown("**What do sliders mean?**")
        st.write("- **Responsibility (0–100):** who mainly owns it (0 = Partner A, 100 = Partner B).")
        st.write("- **Burden (1–5):** how mentally taxing it feels.")
        st.write("- **Fairness (1–5):** how fair it feels right now.")
        st.markdown("**Tips for doing this together**")
        st.write("Talk as you go, keep it light, take a break if needed.")

def safety_note():
    st.info(
        "If anything here feels sensitive, pause and come back later. "
        "This tool is for a constructive chat, not for blame or therapy."
    )

def section_notes(key: str, placeholder: str = "Anything you noticed while answering…"):
    return st.text_area("📝 Notes for this section (optional)", key=key, height=100, placeholder=placeholder)

def tiny_hint(text: str):
    st.caption(text)

def explainer_block(title: str, bullets: List[str]):
    st.markdown(f"**{_esc(title)}**", unsafe_allow_html=True)
    for b in bullets:
        st.write(f"- {b}")


def scroll_to_top():
    """Scroll the app viewport to the top using an embedded script.

    This uses a few approaches in the script to improve reliability across
    different Streamlit embedding/layout variations.
    """
    components.html(
        """
        <script>
            try {
                const mainContent = window.parent.document.querySelector('section.main');
                if (mainContent) {
                    mainContent.scrollTop = 0;
                }
            } catch(e) {}
            try { window.parent.document.body.scrollTop = 0; } catch(e) {}
            try { window.parent.document.documentElement.scrollTop = 0; } catch(e) {}
            try { window.parent.scrollTo(0,0); } catch(e) {}
            try { window.parent.scrollTo({top:0, behavior:'instant'}); } catch(e) {}
        </script>
        """,
        height=0,
    )

def definition_box(
    title: str,
    definition: str,
    what_counts: Optional[List[str]] = None,
    note: Optional[str] = None,
    example: Optional[str] = None,
):
    """Compact definition card used at the top of each task."""
    html_parts = [
        '<div class="card">',
        f'<div class="section-title">{_esc(title)}</div>',
        f'<p>{_esc(definition)}</p>',
    ]
    if what_counts:
        html_parts.append("<ul>")
        for item in what_counts:
            html_parts.append(f"<li>{_esc(item)}</li>")
        html_parts.append("</ul>")

    if example:
        html_parts.append(
            f'<div class="alert-info" style="margin-top:8px;"><strong>Example</strong><br>{_esc(example)}</div>'
        )

    if note:
        html_parts.append(
            f'<p style="color:#475569;margin-top:8px;"><small>{_esc(note)}</small></p>'
        )

    html_parts.append("</div>")
    st.markdown("".join(html_parts), unsafe_allow_html=True)

--END--