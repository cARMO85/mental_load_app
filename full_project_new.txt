The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
README.md
# Mental Load Coach (Streamlit)

A gentle, research-informed tool that helps couples see the *invisible* work and agree one small, 7-day experiment.

## Quick start
```bash
python -m venv .venv
source .venv/bin/activate        # Windows: .venv\Scripts\activate
pip install -r requirements.txt
streamlit run app.py

----
app.py
import streamlit as st
from pathlib import Path

from state import init_state, reset_state
from screens.home import screen_home
from screens.consent import screen_consent
from screens.setup import screen_setup
from screens.questionnaire import screen_questionnaire
from screens.results import screen_results
from screens.learnmore import screen_learn_more
from utils.dev_mode import toggle_dev_mode, is_dev_mode, dev_mode_widget

st.set_page_config(page_title="Mental Load Coach", page_icon="🧠", layout="wide")# ---- CSS ----
def load_css():
    css_path = Path("assets/style.css")
    if css_path.exists():
        st.markdown(f"<style>{css_path.read_text(encoding='utf-8')}</style>", unsafe_allow_html=True)
load_css()

# ---- Init + sidebar nav ----
init_state()

with st.sidebar:
    st.markdown("### Navigation")
    if st.button("🏠 Home"):             st.session_state.stage = "home"
    if st.button("✅ Consent"):          st.session_state.stage = "consent"
    if st.button("⚙️ Setup"):           st.session_state.stage = "setup"
    if st.button("📝 Questionnaire"):    st.session_state.stage = "questionnaire"
    if st.button("📊 Results"):          st.session_state.stage = "results"
    st.divider()
    if st.button("🔁 Start again"):
        reset_state()
        st.session_state.stage = "home"
    
    # Dev mode toggle at bottom
    st.divider()
    dev_mode_enabled = is_dev_mode()
    if st.button(
        f"{'🛠️ Dev Mode: ON' if dev_mode_enabled else '🔧 Dev Mode: OFF'}", 
        use_container_width=True,
        type="primary" if dev_mode_enabled else "secondary"
    ):
        toggle_dev_mode()
        st.rerun()
    
    # Show dev controls if enabled
    dev_mode_widget()
    
    st.caption("You can return here at any time.")

# ---- Router ----
stage = st.session_state.stage
if stage == "home":
    screen_home()
elif stage == "consent":
    screen_consent()
elif stage == "setup":
    screen_setup()
elif stage == "questionnaire":
    screen_questionnaire()
elif stage == "results" or stage == "results_main":
    screen_results()
elif stage == "learn_more":
    screen_learn_more()
else:
    st.session_state.stage = "home"
    screen_home()
----
assets/style.css
/* ===== Base ===== */
:root{
  --bg:#f7fafc; --card:#ffffff; --muted:#64748b;
  --ring:#cbd5e1; --ink:#0f172a; --blue:#2563eb; --green:#16a34a; --amber:#ca8a04; --red:#dc2626;
}
html,body{background:var(--bg)!important;}
.main > div {max-width: 1100px; margin: 0 auto;}

/* Typography */
h1,h2,h3{letter-spacing:.2px}
h1{font-weight:800}
h2{font-weight:700;margin-top:.5rem}
h3{font-weight:700;margin-top:.25rem}
p,li{line-height:1.6}

/* Cards / hero */
.card {
  background: var(--card);
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 2px 8px rgba(0,0,0,.04);
  margin: .5rem 0;
}
.hero{background:linear-gradient(135deg,#eef2ff,#f0f9ff);border:1px solid #e5e7eb;border-radius:16px;padding:26px 22px;margin:6px 0 22px}

/* Coach rail */
.coach{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;position:sticky;top:12px}
.coach .title{font-weight:700}
.coach small{color:var(--muted)}

/* Banner */
.banner{background:#eff6ff;border:1px solid #bfdbfe;padding:12px;border-radius:10px;color:#1e40af}

/* Pills / micro hints */
.pill { display:inline-block; padding:4px 10px; border-radius:999px; background:#eef2ff; color:#1d4ed8; font-weight:600; font-size:.80rem; }
.pill-step { background:#f1f5f9; color:#0f172a; }
.pill-label { margin-left:6px; color:#334155; font-size:.85rem; }
.micro-hint { color:#475569; font-size:.9rem; margin:2px 0 8px; }

/* Examples block */
.examples { background:#f8fafc; border:1px solid #e2e8f0; border-radius:10px; padding:10px 12px; margin:8px 0 6px; }
.examples ul { margin:4px 0 0 18px; }

/* Definition box */
.defbox { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:14px; box-shadow:0 1px 4px rgba(0,0,0,.03); }
.defbox-title { font-weight:700; margin-bottom:6px; }
.defbox-text { color:#334155; margin-bottom:8px; }
.defbox-subtitle { font-weight:600; color:#1f2937; margin-top:4px; margin-bottom:2px; }
.defbox-li { color:#374151; margin-left:4px; }
.defbox-note { margin-top:8px; font-size:.85rem; color:#475569; background:#f8fafc; border:1px dashed #cbd5e1; padding:8px; border-radius:8px; }

/* Slider spacing – keep controls separated */
.stSlider { margin: 6px 0 16px; }
.stSlider label { font-weight:600; margin-bottom: 2px; }
.stSlider [data-baseweb="slider"] { margin-top: 6px; }

/* Notes textarea */
textarea{border-radius:10px !important}

/* Plot spacing */
.blockpad{padding:8px 0}

/* Footer (if you add sticky) */
.footer{position:sticky;bottom:0;z-index:5;background:rgba(255,255,255,.9);backdrop-filter:saturate(180%) blur(6px);border-top:1px solid #e5e7eb;margin-top:16px}
.footer .row{display:flex;justify-content:space-between;align-items:center;padding:10px 6px}
.footer .left{color:#475569;font-size:.9rem}

/* Dataframe trim */
.dataframe td, .dataframe th { border: none !important; }
.dataframe tr { border-bottom: 1px solid #eee; }

.kpi-title { font-size: 0.9rem; color: #475569; font-weight: 600; }
.kpi-value { font-size: 1.8rem; font-weight: 800; line-height: 1.2; margin-top: 4px; color: #0f172a; }
.kpi-caption { font-size: 0.8rem; color: #64748b; margin-top: 2px; }



----
full_project.txt
The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
README.md
# Mental Load Coach (Streamlit)

A gentle, research-informed tool that helps couples see the *invisible* work and agree one small, 7-day experiment.

## Quick start
```bash
python -m venv .venv
source .venv/bin/activate        # Windows: .venv\Scripts\activate
pip install -r requirements.txt
streamlit run app.py

----
app.py
import streamlit as st
from pathlib import Path

from state import init_state, reset_state
from screens.home import screen_home
from screens.consent import screen_consent
from screens.setup import screen_setup
from screens.questionnaire import screen_questionnaire
from screens.results import screen_results
from screens.learnmore import screen_learn_more
from utils.dev_mode import toggle_dev_mode, is_dev_mode, dev_mode_widget

st.set_page_config(page_title="Mental Load Coach", page_icon="🧠", layout="wide")

# ---- CSS ----
def load_css():
    css_path = Path("assets/style.css")
    if css_path.exists():
        st.markdown(f"<style>{css_path.read_text(encoding='utf-8')}</style>", unsafe_allow_html=True)
load_css()

# ---- Init + sidebar nav ----
init_state()

with st.sidebar:
    st.markdown("### Navigation")
    if st.button("🏠 Home"):             st.session_state.stage = "home"
    if st.button("✅ Consent"):          st.session_state.stage = "consent"
    if st.button("⚙️ Setup"):           st.session_state.stage = "setup"
    if st.button("📝 Questionnaire"):    st.session_state.stage = "questionnaire"
    if st.button("📊 Results"):          st.session_state.stage = "results"
    st.divider()
    if st.button("🔁 Start again"):
        reset_state()
        st.session_state.stage = "home"
    
    # Dev mode toggle at bottom
    st.divider()
    dev_mode_enabled = is_dev_mode()
    if st.button(
        f"{'🛠️ Dev Mode: ON' if dev_mode_enabled else '🔧 Dev Mode: OFF'}", 
        use_container_width=True,
        type="primary" if dev_mode_enabled else "secondary"
    ):
        toggle_dev_mode()
        st.rerun()
    
    # Show dev controls if enabled
    dev_mode_widget()
    
    st.caption("You can return here at any time.")

# ---- Router ----
stage = st.session_state.stage
if stage == "home":
    screen_home()
elif stage == "consent":
    screen_consent()
elif stage == "setup":
    screen_setup()
elif stage == "questionnaire":
    screen_questionnaire()
elif stage == "results" or stage == "results_main":
    screen_results()
elif stage == "learn_more":
    screen_learn_more()
else:
    st.session_state.stage = "home"
    screen_home()
----
assets/style.css
/* ===== Base ===== */
:root{
  --bg:#f7fafc; --card:#ffffff; --muted:#64748b;
  --ring:#cbd5e1; --ink:#0f172a; --blue:#2563eb; --green:#16a34a; --amber:#ca8a04; --red:#dc2626;
}
html,body{background:var(--bg)!important;}
.main > div {max-width: 1100px; margin: 0 auto;}

/* Typography */
h1,h2,h3{letter-spacing:.2px}
h1{font-weight:800}
h2{font-weight:700;margin-top:.5rem}
h3{font-weight:700;margin-top:.25rem}
p,li{line-height:1.6}

/* Cards / hero */
.card {
  background: var(--card);
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 16px;
  box-shadow: 0 2px 8px rgba(0,0,0,.04);
  margin: .5rem 0;
}
.hero{background:linear-gradient(135deg,#eef2ff,#f0f9ff);border:1px solid #e5e7eb;border-radius:16px;padding:26px 22px;margin:6px 0 22px}

/* Coach rail */
.coach{background:#fff;border:1px solid #e5e7eb;border-radius:12px;padding:16px;position:sticky;top:12px}
.coach .title{font-weight:700}
.coach small{color:var(--muted)}

/* Banner */
.banner{background:#eff6ff;border:1px solid #bfdbfe;padding:12px;border-radius:10px;color:#1e40af}

/* Pills / micro hints */
.pill { display:inline-block; padding:4px 10px; border-radius:999px; background:#eef2ff; color:#1d4ed8; font-weight:600; font-size:.80rem; }
.pill-step { background:#f1f5f9; color:#0f172a; }
.pill-label { margin-left:6px; color:#334155; font-size:.85rem; }
.micro-hint { color:#475569; font-size:.9rem; margin:2px 0 8px; }

/* Examples block */
.examples { background:#f8fafc; border:1px solid #e2e8f0; border-radius:10px; padding:10px 12px; margin:8px 0 6px; }
.examples ul { margin:4px 0 0 18px; }

/* Definition box */
.defbox { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:14px; box-shadow:0 1px 4px rgba(0,0,0,.03); }
.defbox-title { font-weight:700; margin-bottom:6px; }
.defbox-text { color:#334155; margin-bottom:8px; }
.defbox-subtitle { font-weight:600; color:#1f2937; margin-top:4px; margin-bottom:2px; }
.defbox-li { color:#374151; margin-left:4px; }
.defbox-note { margin-top:8px; font-size:.85rem; color:#475569; background:#f8fafc; border:1px dashed #cbd5e1; padding:8px; border-radius:8px; }

/* Slider spacing – keep controls separated */
.stSlider { margin: 6px 0 16px; }
.stSlider label { font-weight:600; margin-bottom: 2px; }
.stSlider [data-baseweb="slider"] { margin-top: 6px; }

/* Notes textarea */
textarea{border-radius:10px !important}

/* Plot spacing */
.blockpad{padding:8px 0}

/* Footer (if you add sticky) */
.footer{position:sticky;bottom:0;z-index:5;background:rgba(255,255,255,.9);backdrop-filter:saturate(180%) blur(6px);border-top:1px solid #e5e7eb;margin-top:16px}
.footer .row{display:flex;justify-content:space-between;align-items:center;padding:10px 6px}
.footer .left{color:#475569;font-size:.9rem}

/* Dataframe trim */
.dataframe td, .dataframe th { border: none !important; }
.dataframe tr { border-bottom: 1px solid #eee; }

.kpi-title { font-size: 0.9rem; color: #475569; font-weight: 600; }
.kpi-value { font-size: 1.8rem; font-weight: 800; line-height: 1.2; margin-top: 4px; color: #0f172a; }
.kpi-caption { font-size: 0.8rem; color: #64748b; margin-top: 2px; }



----
logic.py
from typing import List, Dict, Tuple
from models import Response

class Calculator:
    def __init__(self, responses: List[Response]):
        self.responses = [r for r in responses if not r.not_applicable]

    def _shares(self) -> Tuple[int,int]:
        # Invisible share: average responsibility across tasks
        if not self.responses:
            return 50, 50
        b_share = sum(r.responsibility for r in self.responses)/ (100*len(self.responses))
        a_pct = round((1 - b_share) * 100)
        b_pct = 100 - a_pct
        return a_pct, b_pct

    def _intensity(self) -> Tuple[int,int]:
        # Map burden (1..5) to 20..100 and weight by share
        if not self.responses: return 0,0
        def scale(b): return 20*b
        a_sum = 0.0; b_sum = 0.0; n = 0
        for r in self.responses:
            n += 1
            a_share = (100 - r.responsibility)/100
            b_share = r.responsibility/100
            a_sum += scale(r.burden) * a_share
            b_sum += scale(r.burden) * b_share
        return round(a_sum/n), round(b_sum/n)

    def pillar_scores(self) -> Dict[str, Tuple[float,float]]:
        d: Dict[str, Tuple[float,float]] = {}
        for r in self.responses:
            a_share = (100 - r.responsibility)/100
            b_share = r.responsibility/100
            a = d.get(r.task.pillar, (0.0,0.0))[0] + a_share*r.burden
            b = d.get(r.task.pillar, (0.0,0.0))[1] + b_share*r.burden
            d[r.task.pillar] = (a,b)
        return d

    def compute(self) -> Dict:
        a_pct, b_pct = self._shares()
        a_int, b_int = self._intensity()
        return dict(
            my_share_pct=a_pct, partner_share_pct=b_pct,
            my_intensity=a_int, partner_intensity=b_int,
            pillar_scores=self.pillar_scores()
        )

    @staticmethod
    def detect_hotspots(responses: List[Response]) -> List[Dict]:
        out = []
        for r in responses:
            reasons = []
            if abs(r.responsibility - 50) >= 30:
                reasons.append("Responsibility imbalance (≥30 pts)")
            if r.burden >= 4:
                reasons.append("High burden")
            if r.fairness <= 2:
                reasons.append("Low perceived fairness")
            if reasons:
                out.append({"task": r.task.name, "reasons": ", ".join(reasons)})
        return out

----
models.py
from pydantic import BaseModel

# models.py (excerpt)
from dataclasses import dataclass, field
from typing import List, Optional

@dataclass
class Task:
    id: str
    name: str
    category: str = "household"
    pillar: str = "identification"    # or anticipation/decision/monitoring/emotional
    requires_children: bool = False
    requires_employment: bool = False

    # (all optional):
    definition: Optional[str] = None
    what_counts: Optional[List[str]] = field(default_factory=list)
    note: Optional[str] = None
    example: Optional[str] = None

class Response(BaseModel):
    task: Task
    responsibility: int          # 0..100 (0=A, 100=B)
    burden: int                  # 1..5
    fairness: int                # 1..5
    not_applicable: bool = False

----
requirements.txt
streamlit>=1.31
pydantic>=2.7
plotly>=5.24
pandas>=2.2

----
screens/__init__.py

----
screens/consent.py
import streamlit as st

def screen_consent():
    st.header("Before we start — a quick agreement")
    st.write("This tool is for kind conversations, not blame. You can stop at any time.")

    kind = st.checkbox("We agree to be kind and pause if it gets tough.")
    consent = st.checkbox("We consent to answer and view results together.")

    st.info("We don’t collect names or emails. Nothing is shared.")
    disabled = not (kind and consent)
    if st.button("Continue to setup →", disabled=disabled):
        st.session_state.stage = "setup"

----
screens/home.py
# screens/home.py
import streamlit as st

def screen_home():
    # Hero section - BIG and clear
    st.markdown("""
    <div style='text-align: center; padding: 60px 20px 40px;'>
        <h1 style='font-size: 3.5rem; font-weight: 800; margin-bottom: 1rem; line-height: 1.1;'>
            You can't share the load<br/>if it's invisible
        </h1>
        <p style='font-size: 1.4rem; color: #64748b; margin-bottom: 2rem; font-weight: 500;'>
            A 20-minute tool to make household mental work visible
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Quick value props (visual cards)
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>📊</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>See the split</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Who's carrying the invisible work?
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>💬</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>Talk it through</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Questions, not accusations
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>🧪</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>Try one change</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Small experiments, not overhauls
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 50px 0 40px;'></div>", unsafe_allow_html=True)
    
    # How it works - SIMPLE
    st.markdown("""
    <div style='text-align: center; margin-bottom: 30px;'>
        <h2 style='font-size: 2rem; font-weight: 700; margin-bottom: 10px;'>Three steps, 20 minutes</h2>
        <p style='font-size: 1.1rem; color: #64748b;'>Do it together. Take breaks if you need them.</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Three steps - VISUAL
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #3b82f6; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>1</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>Answer together</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                10-15 min questionnaire about household tasks
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #8b5cf6; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>2</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>See your results</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                5-page journey through your household patterns
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #10b981; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>3</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>Pick one experiment</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                Agree on one small change to try for a week
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 60px 0 40px;'></div>", unsafe_allow_html=True)
    
    # Key promises - SCANNABLE
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        <div style='background: #f0fdf4; border: 2px solid #86efac; border-radius: 12px; padding: 25px;'>
            <h3 style='font-size: 1.1rem; margin-bottom: 15px; color: #166534;'>✅ What you'll get</h3>
            <ul style='margin: 0; padding-left: 20px; color: #334155;'>
                <li style='margin-bottom: 8px;'>Clear view of who's carrying what</li>
                <li style='margin-bottom: 8px;'>Research-backed conversation questions</li>
                <li style='margin-bottom: 8px;'>Personalised insights you can export</li>
                <li style='margin-bottom: 0;'>One actionable next step</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='background: #fffbeb; border: 2px solid #fde047; border-radius: 12px; padding: 25px;'>
            <h3 style='font-size: 1.1rem; margin-bottom: 15px; color: #854d0e;'>🔒 Privacy promise</h3>
            <ul style='margin: 0; padding-left: 20px; color: #334155;'>
                <li style='margin-bottom: 8px;'>No account or email required</li>
                <li style='margin-bottom: 8px;'>Data stays in your browser only</li>
                <li style='margin-bottom: 8px;'>Nothing sent to any server</li>
                <li style='margin-bottom: 0;'>Gone when you close the tab</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 60px 0 30px;'></div>", unsafe_allow_html=True)
    
    # Pause warning - VISIBLE
    st.warning("""
    ⏸️ **Pause if either of you is tired, stressed, or hungry right now.** This works best when you're both in a good headspace.
    """)
    
    st.markdown("<div style='margin: 30px 0;'></div>", unsafe_allow_html=True)
    
    # CTA - BIG button
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        if st.button("Start now →", use_container_width=True, type="primary"):
            st.session_state.stage = "consent"
            st.rerun()
        st.caption("20 minutes together • No data stored • Research-based")
    
    st.markdown("<div style='margin: 60px 0 20px;'></div>", unsafe_allow_html=True)
    
    # Details in expanders - OPTIONAL reading
    col1, col2 = st.columns(2)
    
    with col1:
        with st.expander("🎓 The research behind this"):
            st.markdown("""
            Based on academic research on household cognitive labour:
            
            - **Daminger (2019)**: Four dimensions of mental work
            - **Dean et al. (2022)**: Mental load and emotional labour
            - **Barigozzi et al. (2025)**: Fairness perceptions matter
            
            Developed for a Master's thesis at a Danish university.
            """)
    
    with col2:
        with st.expander("❓ Who is this for?"):
            st.markdown("""
            **Best for:**
            - Couples living together
            - Partners ready for honest conversation
            - Households where one person feels overwhelmed
            
            **Not a substitute for:**
            - Couples therapy
            - Relationship counselling
            - Crisis intervention
            """)
----
screens/learnmore.py
import streamlit as st

def screen_learn_more():
    st.header("Learn more — how this works")
    st.write("Plain-English overview of the science and design choices.")
    st.markdown("""
- **What we measure:** visible time and the *invisible* planning/monitoring/emotional work.
- **Why a quick estimate:** enough to surface patterns and start a caring conversation.
- **Fairness & care:** This isn’t a test. It’s a helper to agree small, practical changes.
    """)
    st.info("We’ll publish a methods note with sources as your thesis progresses.")

----
screens/questionnaire.py
# screens/questionnaire.py
import streamlit as st
from typing import Dict, List

from tasks import get_filtered_tasks, group_by_pillar
from utils.ui import step_header, learn_popover, safety_note

# --------- Pillar context (conversational, research-grounded) ---------
PILLAR_INTRO: Dict[str, Dict[str, str]] = {
    "anticipation": {
        "title": "🔮 Anticipation: Thinking Ahead",
        "research": "Research identifies anticipation as one of four core dimensions of household cognitive labour (Daminger, 2019). This involves thinking ahead to what will be needed, often before anyone else notices.",
        "what_it_means": "This is the mental work of noticing what will be needed soon and planning for it before it becomes urgent.",
        "example": "Remembering the school form is due Friday, noticing you're low on milk, planning meals for the week."
    },
    "identification": {
        "title": "👁️ Identification: Noticing What Needs Doing",
        "research": "Identification refers to recognising what needs to be done and breaking it down into actionable tasks (Daminger, 2019). Studies show this 'noticing work' is often gendered and invisible to those not doing it.",
        "what_it_means": "This is the work of seeing what needs to happen and defining the actual tasks involved.",
        "example": "Spotting that the bathroom needs cleaning, recognising a child needs new shoes, seeing the light bulb is out."
    },
    "decision": {
        "title": "🤔 Decision-Making: Choosing How & When",
        "research": "Decision-making includes researching options, weighing trade-offs, and coordinating schedules (Daminger, 2019). This 'project management' work is often invisible yet cognitively demanding.",
        "what_it_means": "This is about making choices for the household - which doctor, what gift, how to handle a situation.",
        "example": "Choosing which childcare, deciding what to cook, picking a birthday gift, scheduling appointments."
    },
    "monitoring": {
        "title": "📋 Monitoring: Following Up & Tracking",
        "research": "Monitoring involves tracking whether tasks are completed and following up when needed (Daminger, 2019). Research emphasises this as a particularly invisible form of cognitive labour that can remain stressful even when tasks are delegated.",
        "what_it_means": "This is the work of tracking progress, remembering deadlines, and ensuring things don't fall through the cracks.",
        "example": "Checking if forms got submitted, following up on RSVPs, tracking when bills are due, reminding about tasks."
    },
    "emotional": {
        "title": "💝 Emotional Labour: The Caring Work",
        "research": "Emotional labour includes managing feelings, maintaining relationships, and creating household harmony (Dean, Churchill and Ruppanner, 2022). Research now recognises this as cognitive work, not simply 'being nice'.",
        "what_it_means": "This is about noticing and responding to others' feelings, maintaining family relationships, and creating a positive home environment.",
        "example": "Soothing upset children, remembering to call grandma, managing conflicts, creating special moments."
    }
}

# --------- Helper for task display ---------
def _render_task_card(task, default=None):
    """Simplified, conversation-focused task card"""
    
    # Task name as header
    st.markdown(f"### {task.name}")
    
    # Brief definition (not overwhelming)
    if task.definition:
        st.markdown(f"*{task.definition}*")
    
    # What counts (in a compact format)
    if task.what_counts:
        with st.expander("💡 What this includes"):
            for item in task.what_counts:
                st.markdown(f"• {item}")
    
    # Example if helpful
    if task.example:
        st.info(f"**Example:** {task.example}")
    
    st.markdown("")  # Spacing
    
    # Three questions, presented more conversationally
    st.markdown("**Answer these three questions together:**")
    
    col1, col2 = st.columns([3, 1])
    
    with col1:
        # 1. Responsibility
        st.markdown("**1. Who mainly handles this right now?**")
        responsibility = st.slider(
            "Slide toward the person who carries most of this mental work",
            min_value=0, 
            max_value=100, 
            value=(default or {}).get("responsibility", 50),
            key=f"{task.id}_resp",
            help="0 = Partner A does all of it, 50 = shared equally, 100 = Partner B does all of it",
            label_visibility="collapsed"
        )
        
        # Visual label
        if responsibility < 30:
            st.caption("← Partner A handles most of this")
        elif responsibility > 70:
            st.caption("Partner B handles most of this →")
        else:
            st.caption("↔️ Shared fairly evenly")
        
        st.markdown("")
        
        # 2. Burden
        st.markdown("**2. How mentally draining is this task?**")
        st.caption("For whoever mainly handles it - how heavy does it feel?")
        burden = st.slider(
            "Burden level",
            min_value=1, 
            max_value=5, 
            value=(default or {}).get("burden", 3),
            key=f"{task.id}_burden",
            help="1 = Easy/light, 5 = Very draining",
            label_visibility="collapsed"
        )
        
        # Visual feedback
        burden_labels = {1: "😌 Light", 2: "🙂 Manageable", 3: "😐 Moderate", 4: "😓 Heavy", 5: "😰 Very draining"}
        st.caption(burden_labels.get(burden, ""))
        
        st.markdown("")
        
        # 3. Fairness
        st.markdown("**3. Does this feel fair right now?**")
        st.caption("Your gut feeling - not what 'should' be fair, but how it actually feels")
        fairness = st.slider(
            "Fairness feeling",
            min_value=1, 
            max_value=5, 
            value=(default or {}).get("fairness", 3),
            key=f"{task.id}_fair",
            help="1 = Very unfair, 5 = Completely fair",
            label_visibility="collapsed"
        )
        
        # Visual feedback
        fairness_labels = {1: "😞 Feels unfair", 2: "😕 Not quite fair", 3: "😐 Neutral", 4: "🙂 Pretty fair", 5: "😊 Feels fair"}
        st.caption(fairness_labels.get(fairness, ""))
    
    with col2:
        st.markdown("**Not relevant?**")
        not_applicable = st.checkbox(
            "Skip this task",
            value=(default or {}).get("not_applicable", False),
            key=f"{task.id}_na",
            help="Check this if this task doesn't apply to your household"
        )
    
    return {
        "task_id": task.id,
        "responsibility": responsibility,
        "burden": burden,
        "fairness": fairness,
        "not_applicable": not_applicable,
    }


# --------- Main screen ---------
def screen_questionnaire():
    # Initialize state
    st.session_state.setdefault("q_pillar_index", 0)
    st.session_state.setdefault("responses", [])
    st.session_state.setdefault("notes_by_section", {})

    # Get context
    children = st.session_state.get("children", 0)
    household_type = st.session_state.get("household_type", "couple")
    is_emp_me = st.session_state.get("is_employed_me", True)
    is_emp_partner = st.session_state.get("is_employed_partner", True) if household_type == "couple" else False
    both_employed = (is_emp_me and is_emp_partner) if household_type == "couple" else is_emp_me

    tasks = get_filtered_tasks(children, both_employed)
    groups = group_by_pillar(tasks)

    # Pillar order
    ordered = ["anticipation", "identification", "decision", "monitoring", "emotional"]
    pillar_keys: List[str] = [k for k in ordered if k in groups] + [k for k in groups.keys() if k not in ordered]

    # Progress
    total_sections = len(pillar_keys)
    i = st.session_state.q_pillar_index
    progress = int((i / max(total_sections, 1)) * 100)

    # Header
    st.title("📝 Household Questionnaire")
    st.caption(f"Section {i+1} of {total_sections} • Talk it through together as you go")
    st.progress(progress)
    
    # Top navigation
    col1, col2, col3 = st.columns([1, 1, 1])
    with col1:
        if st.button("🏠 Home", use_container_width=True):
            st.session_state.stage = "home"
            st.rerun()
    with col2:
        learn_popover()
    with col3:
        if st.button("💾 Save & Exit", use_container_width=True):
            st.info("Your progress is saved in this session. You can return anytime before closing the browser.")
            st.session_state.stage = "home"
            st.rerun()

    st.markdown("---")

    if not pillar_keys:
        st.warning("No tasks available for your context. Try adjusting Setup.")
        if st.button("← Back to Setup"):
            st.session_state.stage = "setup"
            st.rerun()
        return

    # Current pillar
    pillar = pillar_keys[i]
    pillar_info = PILLAR_INTRO.get(pillar, {})
    
    # Pillar introduction (research-grounded)
    st.markdown(f"## {pillar_info.get('title', pillar.capitalize())}")
    
    with st.expander("🎓 Why we're asking about this", expanded=(i == 0)):
        st.markdown(f"**What research shows:** {pillar_info.get('research', '')}")
        st.markdown(f"**What it means:** {pillar_info.get('what_it_means', '')}")
        st.markdown(f"**Example:** {pillar_info.get('example', '')}")
    
    st.markdown("---")
    
    # Gentle reminder
    if i == 0:
        st.info("💙 **Remember:** There are no right answers. Just your honest experience right now. Take breaks if you need them.")
    
    # Tasks in this section
    section_tasks = groups[pillar]
    st.markdown(f"### {len(section_tasks)} tasks in this section")
    st.caption("For each task, answer together. It's okay to disagree - note different perspectives at the bottom.")
    
    st.markdown("---")
    
    # Render tasks
    updated = []
    for idx, t in enumerate(section_tasks, 1):
        st.markdown(f"#### Task {idx} of {len(section_tasks)}")
        prev = next((r for r in st.session_state.responses if r["task_id"] == t.id), None)
        resp = _render_task_card(t, default=prev)
        updated.append(resp)
        st.markdown("---")

    # Merge updates
    other = [r for r in st.session_state.responses if r["task_id"] not in {t.id for t in section_tasks}]
    st.session_state.responses = other + updated

    # Notes for this section
    st.markdown("### 📝 Notes for this section (optional)")
    st.caption("Different perspectives? Something that felt particularly heavy? An idea to try? Jot it down.")
    
    note_key = f"notes_{pillar}"
    existing_note = st.session_state.notes_by_section.get(pillar, "")
    
    new_note = st.text_area(
        "Your notes:",
        value=existing_note,
        height=100,
        placeholder="E.g., 'Partner A didn't realize Partner B was tracking all the meal planning' or 'We both want to try meal-prepping on Sundays'",
        key=note_key,
        help="These notes stay in your browser session and can be exported with your results."
    )
    st.session_state.notes_by_section[pillar] = new_note

    # Navigation
    st.markdown("---")
    st.markdown("### Ready to continue?")
    
    colA, colB, colC = st.columns([1, 1, 2])
    with colA:
        if st.button("⬅️ Previous Section", disabled=(i == 0), use_container_width=True):
            if i > 0:
                st.session_state.q_pillar_index = i - 1
                st.rerun()
    with colB:
        if i < total_sections - 1:
            if st.button("Next Section ➡️", use_container_width=True, type="primary"):
                st.session_state.q_pillar_index = i + 1
                st.rerun()
        else:
            if st.button("See Results →", use_container_width=True, type="primary"):
                if not st.session_state.responses:
                    st.warning("Please answer at least one task first.")
                else:
                    st.session_state.results_prep_seen = False  # Force showing prep screen
                    st.session_state.stage = "results"
                    st.rerun()
    
    with colC:
        # Progress indicator
        completed = sum(1 for r in st.session_state.responses if not r.get("not_applicable", False))
        total_tasks = len(tasks)
        st.caption(f"📊 Progress: {completed} of {total_tasks} tasks completed")
----
screens/results.py
# screens/results.py
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List

from state import reset_state
from tasks import TASK_LOOKUP
from models import Response
from logic import Calculator

A_COL = "#0072B2"  # Okabe–Ito blue (Partner A)
B_COL = "#E69F00"  # Okabe–Ito orange (Partner B)
GRID = "rgba(0,0,0,0.08)"

PILLAR_ORDER = ["anticipation", "identification", "decision", "monitoring", "emotional"]
PILLAR_LABELS = {
    "anticipation": "Anticipation",
    "identification": "Identification",
    "decision": "Decision",
    "monitoring": "Monitoring",
    "emotional": "Emotional",
}

# ---------- utils ----------
def _to_response_objects(response_dicts):
    objs = []
    for r in response_dicts:
        task = TASK_LOOKUP.get(r["task_id"])
        if not task:
            continue
        objs.append(
            Response(
                task=task,
                responsibility=int(r["responsibility"]),
                burden=int(r["burden"]),
                fairness=int(r["fairness"]),
                not_applicable=bool(r.get("not_applicable", False)),
            )
        )
    return objs

def _ensure_all_pillars(scores: Dict[str, List[float]]) -> Dict[str, List[float]]:
    """Guarantee all five pillars exist; fill missing with zeros."""
    out = {}
    for k in PILLAR_ORDER:
        out[k] = list(scores.get(k, [0.0, 0.0]))
        if len(out[k]) != 2:
            out[k] = [0.0, 0.0]
    return out

def _plain_reason(raw: str) -> str:
    s = raw or ""
    s = s.replace("Responsibility imbalance (≥30 pts)", "One partner is handling most of this")
    s = s.replace("High burden", "This feels particularly draining")
    s = s.replace("Low perceived fairness", "This doesn't feel fair to one or both partners")
    return s

def _reason_to_question(reasons: str) -> str:
    """Convert reasons into conversation questions"""
    r = (reasons or "").lower()
    if "lopsided" in r or "imbalance" in r or "handling most" in r:
        return "How did this become one person's responsibility? Was it a deliberate choice?"
    if "doesn't feel fair" in r or "fairness" in r:
        return "What would 'fair' look like to each of you for this task?"
    if "heavy" in r or "burden" in r or "draining" in r:
        return "What makes this task feel so heavy? Could part of it be shared or simplified?"
    return "What's one small thing that might make this easier?"

def _add_notes_section(page_name: str):
    """Add optional notes section with clear privacy messaging"""
    with st.expander("📝 Add notes from your conversation (optional)"):
        st.info("""
        **Privacy promise:** 
        - These notes are ONLY stored in your browser's temporary session
        - They're included in your CSV export if you download it
        - Nothing is sent to any server or saved anywhere else
        - When you close this browser tab, they're gone forever
        """)
        
        # Initialize notes dict if it doesn't exist
        if "results_notes" not in st.session_state:
            st.session_state.results_notes = {}
        
        # Get existing note for this page
        existing_note = st.session_state.results_notes.get(page_name, "")
        
        note = st.text_area(
            "Your notes:",
            value=existing_note,
            height=120,
            placeholder="Jot down insights, agreements, or things to try...",
            key=f"note_{page_name}",
            help="These notes are only stored temporarily in your browser and included in your export."
        )
        
        # Save note to session state
        st.session_state.results_notes[page_name] = note

# ---------- visuals ----------
def comparison_bars(a_val: int, b_val: int, max_val: int = 100, label_a="Partner A", label_b="Partner B"):
    """Simple horizontal comparison bars"""
    fig = go.Figure()
    
    fig.add_trace(go.Bar(
        y=[label_a, label_b],
        x=[a_val, b_val],
        orientation='h',
        marker=dict(color=[A_COL, B_COL]),
        text=[f"{a_val}", f"{b_val}"],
        textposition='outside',
        textfont=dict(size=20, color='black'),
    ))
    
    fig.update_layout(
        height=150,
        margin=dict(l=120, r=60, t=10, b=10),
        xaxis=dict(range=[0, max_val], showgrid=False, showticklabels=False),
        yaxis=dict(showgrid=False),
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        showlegend=False,
    )
    
    return fig

def pillar_grouped_bar(pillar_scores: Dict[str, List[float]]) -> go.Figure:
    scores = _ensure_all_pillars(pillar_scores)
    rows = []
    for k in PILLAR_ORDER:
        a, b = scores[k]
        rows.append({"Pillar": PILLAR_LABELS[k], "Partner": "A", "Score": a})
        rows.append({"Pillar": PILLAR_LABELS[k], "Partner": "B", "Score": b})
    df = pd.DataFrame(rows)
    df["Pillar"] = pd.Categorical(df["Pillar"], categories=[PILLAR_LABELS[k] for k in PILLAR_ORDER], ordered=True)

    fig = px.bar(
        df.sort_values("Pillar"),
        x="Pillar", y="Score", color="Partner",
        barmode="group", template="simple_white",
        color_discrete_map={"A": A_COL, "B": B_COL},
    )
    fig.update_layout(
        height=300,
        margin=dict(l=10, r=10, t=10, b=10),
        legend=dict(orientation="h", y=1.08, x=0.0),
    )
    fig.update_xaxes(showgrid=False, ticks="")
    fig.update_yaxes(gridcolor=GRID, zeroline=False, title="")
    return fig

# ---------- CSV export ----------
def _export_csv(responses, results, hotspots):
    df = pd.DataFrame(responses)
    csv = df.to_csv(index=False)

    summary = pd.DataFrame(
        {
            "Metric": [
                "Partner A load (0–100)",
                "Partner B load (0–100)",
                "Partner A invisible share (%)",
                "Partner B invisible share (%)",
            ],
            "Value": [
                results["my_intensity"],
                results["partner_intensity"],
                results["my_share_pct"],
                results["partner_share_pct"],
            ],
        }
    )
    csv += "\n\nSUMMARY\n" + summary.to_csv(index=False)

    p = _ensure_all_pillars(results.get("pillar_scores", {}))
    p_rows = [{"Pillar": PILLAR_LABELS[k], "Partner A sum": round(v[0], 2), "Partner B sum": round(v[1], 2)} for k, v in p.items()]
    csv += "\n\nPILLAR BREAKDOWN\n" + pd.DataFrame(p_rows).to_csv(index=False)

    if hotspots:
        hs_rows = [{"Task": h.get("task", ""), "Why it matters": _plain_reason(h.get("reasons", "")), "Question to discuss": _reason_to_question(h.get("reasons", ""))} for h in hotspots]
        csv += "\n\nCONVERSATION STARTERS\n" + pd.DataFrame(hs_rows).to_csv(index=False)

    # Include conversation notes if any exist
    notes = st.session_state.get("results_notes", {})
    if any(v.strip() for v in notes.values()):
        csv += "\n\nYOUR CONVERSATION NOTES\n"
        notes_rows = []
        for page, note in notes.items():
            if note.strip():
                notes_rows.append({"Page": page, "Notes": note.strip()})
        if notes_rows:
            csv += pd.DataFrame(notes_rows).to_csv(index=False)

    return csv

# ---------- conversation prep screen ----------
def screen_before_results():
    """Pre-results conversation guide"""
    st.title("💬 Before You See Your Results")
    st.markdown("### A few minutes to prepare for a productive conversation")
    
    st.markdown("""
    You're about to see data about mental load in your household. This can bring up big feelings - 
    that's completely normal and actually a sign you're both invested in your partnership.
    """)
    
    st.markdown("---")
    
    st.markdown("### 🎓 What Research Tells Us")
    st.info("""
    **Mental load** (also called cognitive labor) is the invisible work of managing a household: 
    anticipating needs, making decisions, tracking details, and coordinating family life.
    
    Research consistently shows:
    - This work is often invisible to the person not doing it
    - In heterosexual couples, women typically carry 70-80% of this load
    - It's **not about time spent** - it's about the mental energy of being "on call"
    - Even in couples who split visible tasks 50/50, mental load is often imbalanced
    - The biggest predictor of relationship satisfaction isn't perfect equality - it's feeling **heard and understood**
    """)
    
    st.markdown("### 🤝 Ground Rules for This Conversation")
    st.success("""
    **Do:**
    - Assume good intentions
    - Listen to understand, not to defend
    - Notice what surprises you
    - Acknowledge the other person's feelings as valid
    - Take breaks if it gets intense
    
    **Don't:**
    - Keep score or bring up past grievances  
    - Interrupt or dismiss
    - Try to "win" the conversation
    - Expect to solve everything today
    """)
    
    st.markdown("### 🎯 The Goal of This Exercise")
    st.markdown("""
    The point isn't to create perfect 50/50 splits or to prove who's right. 
    
    **The goal is to:**
    1. Make invisible work visible
    2. Understand each other's experience
    3. Find 1-2 small changes you both agree to try
    4. Build a habit of checking in together
    """)
    
    st.markdown("---")
    
    st.markdown("### ✋ Before You Continue")
    st.warning("""
    **Pause here if:**
    - Either of you is tired, hungry, or stressed right now
    - You've been arguing about this recently
    - One of you isn't ready to have this conversation
    
    This tool will be here when you're both ready. There's no rush.
    """)
    
    st.markdown("---")
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("← Back to questionnaire", use_container_width=True):
            st.session_state.stage = "questionnaire"
            st.rerun()
    with col2:
        if st.button("We're ready - show results →", use_container_width=True, type="primary"):
            st.session_state.results_page = 1
            st.session_state.stage = "results_main"
            st.rerun()

# ---------- PAGINATED RESULTS SECTIONS ----------

def _results_page_1_share(results, hotspots):
    """Page 1: The Big Picture - Who's Carrying What"""
    st.title("📊 Your Results: The Big Picture")
    st.caption("💙 Remember: This is about understanding, not blame.")
    st.progress(20)  # 1 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 📚 Context: What Research Shows")
    
    with st.expander("📖 Click to read about mental load patterns in households"):
        st.markdown("""
        Studies of household labor consistently find:
        
        - **Visible vs. Invisible Split:** Even when couples split physical tasks evenly, the invisible work 
          (planning, remembering, coordinating) is often held by one partner
        - **The "Manager-Helper" Dynamic:** One partner acts as the household manager who delegates, 
          while the other helps when asked - but doesn't carry the mental burden of anticipating needs
        - **Gendered Patterns:** In heterosexual couples, research shows women typically carry 2-3x 
          more cognitive labor, regardless of employment status
        - **Why It Matters:** Unacknowledged mental load is strongly linked to resentment, burnout, 
          and relationship dissatisfaction
        - **Good News:** Simply naming and discussing mental load improves outcomes, even before changes are made
        """)
    
    st.markdown("### 🔍 Your Household's Snapshot")
    st.markdown("Here's what your responses show about mental load distribution right now.")
    
    a_share, b_share = results["my_share_pct"], results["partner_share_pct"]
    
    # Share percentages
    st.markdown("**Mental load share (who's carrying the invisible work):**")
    st.plotly_chart(comparison_bars(a_share, b_share, 100, "Partner A", "Partner B"), use_container_width=True)
    
    # Research context for their numbers
    diff = abs(a_share - b_share)
    if diff <= 15:
        st.success("✅ **Your household shows relatively balanced mental load.** Research suggests 60/40 or closer is associated with higher relationship satisfaction.")
    elif diff <= 30:
        st.info("📊 **Your split is common.** About 60% of couples show this pattern. The question is: does it feel sustainable to both of you?")
    else:
        st.warning("📊 **This pattern is common but can lead to burnout.** Research shows splits beyond 70/30 often predict resentment over time - but this is changeable.")
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - Does this percentage match how it *feels* in daily life?
    - What surprises you about this number?
    - What might explain this pattern in your household?
    """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 1: The Big Picture")


def _results_page_2_burden(results):
    """Page 2: How Heavy Does It Feel"""
    st.title("📊 How Heavy Does It Feel?")
    st.caption("💙 Understanding the emotional weight of invisible work")
    st.progress(40)  # 2 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 😰 Personal Burden")
    st.markdown("""
    **Personal burden (0-100):** This isn't about how much time tasks take - it's about how draining 
    the mental work feels.
    
    Research shows mental load burden comes from:
    - Being "on call" mentally even during downtime
    - The invisible work of anticipating others' needs
    - Carrying responsibility without recognition
    """)
    
    a_int, b_int = results["my_intensity"], results["partner_intensity"]
    st.plotly_chart(comparison_bars(a_int, b_int, 100, "Partner A", "Partner B"), use_container_width=True)
    
    # Research context
    load_diff = abs(a_int - b_int)
    if load_diff <= 15:
        st.success("Both partners report similar burden levels - this suggests the mental energy feels fairly distributed.")
    elif load_diff <= 30:
        heavier = "Partner A" if a_int > b_int else "Partner B"
        st.info(f"📊 {heavier} reports feeling more burdened. This is worth exploring - sometimes visible task-sharing doesn't capture invisible stress.")
    else:
        heavier = "Partner A" if a_int > b_int else "Partner B"
        st.warning(f"⚠️ {heavier}'s burden score is notably higher. Research links sustained high burden to burnout and relationship strain.")
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - For the person with higher burden: What makes it feel heavy? Is it the tasks themselves, or the mental energy of managing them?
    - For the person with lower burden: Does this surprise you? What might you not be seeing?
    - Are there times of day or week when burden peaks for each of you?
    """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 2: How Heavy Does It Feel")


def _results_page_3_pillars(results):
    """Page 3: The Five Pillars"""
    st.title("📊 Where the Mental Load Lives")
    st.caption("💙 Breaking down the five types of invisible work")
    st.progress(60)  # 3 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 🏛️ The Five Pillars of Mental Load")
    st.markdown("""
    Research identifies five types of cognitive labor in households. This chart shows which 
    partner is carrying more of each type.
    """)
    
    with st.expander("ℹ️ What these five pillars mean (click to expand)"):
        st.markdown("""
        Based on research in household labor and emotional work:
        
        - **Anticipation:** Thinking ahead to what will be needed (meal planning, remembering appointments, 
          anticipating when supplies run low)
        - **Identification:** Noticing what needs doing (seeing the mess, recognizing when something's broken, 
          spotting when someone needs support)
        - **Decision-Making:** Researching options and making choices (which doctor, what gift, how to handle 
          a situation)
        - **Monitoring:** Tracking progress and following up (did the form get submitted? Is the kids' project 
          done? Are we running low on groceries?)
        - **Emotional Labor:** Managing feelings, maintaining relationships, providing support, creating 
          household harmony
        
        **Key finding:** The monitoring and anticipation pillars are often most invisible to the partner not doing them.
        """)
    
    pillar_scores = _ensure_all_pillars(results.get("pillar_scores", {}))
    st.plotly_chart(pillar_grouped_bar(pillar_scores), use_container_width=True)
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - Which pillar shows the biggest difference between you?
    - Is there a pillar where one person didn't realize how much the other was doing?
    - Research shows "monitoring" is often invisible - does that resonate?
    """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 3: The Five Pillars")


def _results_page_4_hotspots(hotspots):
    """Page 4: Conversation Starters"""
    st.title("📊 Conversation Starters")
    st.caption("💙 Topics worth exploring together")
    st.progress(80)  # 4 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 💬 Areas to Explore")
    st.markdown("""
    These aren't "problems to fix" - they're **topics worth exploring together**. 
    
    Research shows that couples who regularly discuss mental load (even without making immediate changes) 
    report higher satisfaction than those who don't talk about it.
    """)
    
    if hotspots:
        st.info(f"📌 We've identified {len(hotspots)} areas where responses suggest an imbalance, high burden, or fairness concern. Start with one.")
        
        # Show top 3 as conversation starters
        for i, h in enumerate(hotspots[:3], 1):
            with st.container():
                st.markdown(f"### {i}. {h.get('task', 'Task')}")
                
                col1, col2 = st.columns([1, 1])
                with col1:
                    plain = _plain_reason(h.get("reasons", ""))
                    st.markdown(f"**Why it came up:** {plain}")
                
                with col2:
                    question = _reason_to_question(h.get("reasons", ""))
                    st.markdown(f"**💭 Discuss:** {question}")
                
                st.markdown("")
        
        # Remaining in expander
        if len(hotspots) > 3:
            with st.expander(f"📋 See {len(hotspots) - 3} more conversation starters"):
                for i, h in enumerate(hotspots[3:], 4):
                    st.markdown(f"**{i}. {h.get('task', 'Task')}**")
                    st.markdown(f"*{_plain_reason(h.get('reasons', ''))}*")
                    st.markdown(f"💭 *{_reason_to_question(h.get('reasons', ''))}*")
                    st.markdown("")
    else:
        st.success("""
        🎉 **No major conversation starters detected!** 
        
        Your responses suggest relatively balanced mental load distribution. This is worth celebrating!
        
        Still, research recommends checking in periodically - life circumstances change, and what works 
        now might need adjustment later.
        """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 4: Conversation Starters")


def _results_page_5_action():
    """Page 5: What's Next"""
    st.title("📊 What's Next")
    st.caption("💙 Building from strengths and trying small experiments")
    st.progress(100)  # 5 of 5 pages
    
    st.markdown("---")
    
    # ====== WHAT'S WORKING ======
    st.markdown("## ✨ What's Working Well")
    st.markdown("""
    Research on couple interventions shows that building from strengths is more effective than 
    only focusing on problems.
    """)
    
    # Find areas of relative balance
    balanced_areas = []
    for task_response in st.session_state.responses:
        resp_diff = abs(task_response.get("responsibility", 50) - 50)
        if resp_diff <= 20 and task_response.get("burden", 50) < 60:
            task = TASK_LOOKUP.get(task_response["task_id"])
            if task:
                balanced_areas.append(task.name)
    
    if balanced_areas:
        st.success(f"**Areas showing good balance:** {', '.join(balanced_areas[:5])}")
        st.markdown("💭 **Discuss:** What makes these areas work well? Can you apply that pattern elsewhere?")
    else:
        st.info("**Every household has strengths.** What's one thing you're both proud of in how you manage your home together?")
    
    st.markdown("---")
    
    # ====== EXPERIMENT ======
    st.markdown("## 🧪 Try One Small Experiment")
    st.markdown("""
    Research on behavior change shows that small, time-bound experiments work better than big overhauls.
    
    **The invitation:** Pick ONE thing from your conversation starters. Agree to try a small change 
    for one week, then check in.
    """)
    
    st.info("""
    **What makes a good experiment:**
    - Specific (not "help more" but "Partner B will plan meals Tuesday-Thursday")
    - Time-bound (try for one week)
    - Agreed by both (not imposed on one person)
    - Reversible (you can always go back)
    """)
    
    st.markdown("---")
    st.markdown("## 🎉 You've Completed the Journey")
    st.success("""
    You've taken an important step toward understanding mental load in your household. 
    
    **Next steps:**
    - Add any final notes below
    - Download your results (including all your notes)
    - Try your small experiment for one week
    - Check in together next weekend
    - Return to this tool in a month to see how things have shifted
    """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 5: Action Plan & Experiment")


# ---------- main results navigation ----------
def screen_results_main():
    """Main results with pagination"""
    
    if not st.session_state.get("responses"):
        st.warning("No results yet. Please complete the questionnaire first.")
        return

    # compute results once
    response_objs = _to_response_objects(st.session_state.responses)
    calc = Calculator(response_objs)
    results = calc.compute()
    hotspots = Calculator.detect_hotspots(response_objs)

    # Initialize page if not set
    if "results_page" not in st.session_state:
        st.session_state.results_page = 1
    
    current_page = st.session_state.results_page
    
    # Header navigation (always visible)
    col1, col2, col3 = st.columns([2, 1, 1])
    with col1:
        st.caption(f"Page {current_page} of 5")
    with col2:
        if st.button("🔁 Start Over", use_container_width=True):
            reset_state()
            st.session_state.stage = "home"
            st.rerun()
    with col3:
        csv_data = _export_csv(st.session_state.responses, results, hotspots)
        st.download_button(
            "📥 Export",
            data=csv_data,
            file_name="mental_load_results.csv",
            mime="text/csv",
            use_container_width=True,
        )
    
    st.markdown("---")
    
    # Render current page
    if current_page == 1:
        _results_page_1_share(results, hotspots)
    elif current_page == 2:
        _results_page_2_burden(results)
    elif current_page == 3:
        _results_page_3_pillars(results)
    elif current_page == 4:
        _results_page_4_hotspots(hotspots)
    elif current_page == 5:
        _results_page_5_action()
    
    # Show note count if any notes exist
    notes = st.session_state.get("results_notes", {})
    note_count = sum(1 for v in notes.values() if v.strip())
    if note_count > 0:
        st.info(f"📝 You have notes on {note_count} page(s) - they'll be included in your export")
    
    # Navigation footer (always at bottom)
    st.markdown("---")
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col1:
        if current_page > 1:
            if st.button("← Previous", use_container_width=True):
                st.session_state.results_page -= 1
                st.rerun()
        else:
            st.button("← Previous", disabled=True, use_container_width=True)
    
    with col2:
        # Page indicators
        dots = ""
        for i in range(1, 6):
            if i == current_page:
                dots += "🔵 "
            else:
                dots += "⚪ "
        st.markdown(f"<div style='text-align: center; padding: 8px;'>{dots}</div>", unsafe_allow_html=True)
    
    with col3:
        if current_page < 5:
            if st.button("Next →", use_container_width=True, type="primary"):
                st.session_state.results_page += 1
                st.rerun()
        else:
            if st.button("🏠 Finish", use_container_width=True, type="primary"):
                st.session_state.stage = "home"
                st.rerun()
    
    st.markdown("---")
    st.caption("""
    💙 **Remember:** This is one snapshot in time. Mental load shifts with life circumstances. 
    The healthiest couples check in regularly, not just once.
    """)


# ---------- Main entry point ----------
def screen_results():
    """Route to either prep screen or main results"""
    # First time seeing results? Show prep screen
    if not st.session_state.get("results_prep_seen", False):
        screen_before_results()
        st.session_state.results_prep_seen = True
    else:
        # They've seen prep, show paginated results
        screen_results_main()
----
screens/setup.py
import streamlit as st
from tasks import get_filtered_tasks

def screen_setup():
    st.header("Household context (for couples)")
    st.caption("We ask only what’s needed to tailor the questionnaire.")

    c1,c2,c3 = st.columns([2,1,1])
    with c1:
        children = st.number_input("Number of children", min_value=0, max_value=10, step=1, value=st.session_state.children)
        st.session_state.children = children
    with c2:
        st.session_state.is_employed_me = st.checkbox("Partner A employed?", value=st.session_state.is_employed_me)
    with c3:
        st.session_state.is_employed_partner = st.checkbox("Partner B employed?", value=st.session_state.is_employed_partner)

    both_employed = st.session_state.is_employed_me and st.session_state.is_employed_partner
    filtered = get_filtered_tasks(st.session_state.children, both_employed)
    st.success(f"{len(filtered)} items selected for your context. Child-related items only show if you have children; some work items only if both are employed.")

    if st.button("Start questionnaire →", type="primary"):
        st.session_state.q_section_index = 0
        st.session_state.q_task_index = 0
        st.session_state.responses = []
        st.session_state.notes_by_section = {}
        st.session_state.stage = "questionnaire"

----
state.py
import streamlit as st

def init_state():
    defaults = dict(
        stage="home",
        # setup
        household_type="couple",
        children=0,
        is_employed_me=True,
        is_employed_partner=True,
        # questionnaire progress
        q_section_index=0,
        q_task_index=0,
        responses=[],              # list of dicts {task_id, responsibility, burden, fairness, not_applicable}
        notes_by_section={},       # pillar -> str
    )
    for k,v in defaults.items():
        if k not in st.session_state:
            st.session_state[k] = v

def reset_state():
    keys = list(st.session_state.keys())
    for k in keys:
        del st.session_state[k]
    init_state()

----
tasks.py
# tasks.py - EXPANDED VERSION
from typing import List, Dict
from models import Task

TASKS: list[Task] = [
    # ========== ANTICIPATION PILLAR ==========
    
    Task(
        id="meal_planning",
        name="Meal planning & grocery list",
        pillar="anticipation",
        definition=(
            "By meal planning & prep we mean the *whole* flow — not just cooking, "
            "but deciding what to eat, checking what's low, building the list, and "
            "sequencing the week so food actually happens."
        ),
        what_counts=[
            "Noticing what's low / planning the week's meals",
            "Creating or updating the grocery list / booking delivery/pick-up",
            "Remembering dietary needs, timings, after-school or late-work days",
            "Prepping ahead (marinating, batch cooking) so the week runs",
        ],
        note="Answer for the 'invisible' work here (planning/organising); the cooking task itself is separate.",
        example="If one partner mostly plans and manages the list, set Responsibility nearer their side (e.g., 70–90).",
    ),
    
    Task(
        id="household_supplies",
        name="Household supplies & consumables",
        pillar="anticipation",
        definition=(
            "Noticing when household items are running low and ensuring they're restocked before you run out."
        ),
        what_counts=[
            "Tracking toilet paper, cleaning products, toiletries",
            "Noticing when bins need new bags, dishwasher needs tablets",
            "Ordering or buying replacements before they run out",
            "Remembering what brands/types each person prefers",
        ],
        example="If one partner notices and orders everything, Responsibility ~80-100 to them.",
    ),
    
    Task(
        id="birthday_gifts",
        name="Gifts, cards & social obligations",
        pillar="anticipation",
        definition=(
            "Remembering birthdays, anniversaries, and social occasions, and organising cards, gifts, or RSVPs."
        ),
        what_counts=[
            "Remembering family/friends' birthdays and important dates",
            "Choosing, buying, wrapping gifts",
            "Sending cards or organising celebrations",
            "Tracking RSVPs and social commitments",
        ],
        example="If one partner manages the family calendar of social obligations, Responsibility ~70-100.",
    ),
    
    Task(
        id="seasonal_prep",
        name="Seasonal & future planning",
        pillar="anticipation",
        definition=(
            "Thinking ahead to seasonal needs, holidays, and future household requirements."
        ),
        what_counts=[
            "Planning for holidays, school breaks, seasons changing",
            "Preparing for birthdays, Christmas, summer holidays",
            "Anticipating when kids need new clothes/shoes/school supplies",
            "Thinking ahead about home repairs or maintenance",
        ],
        example="If one partner does most of the forward-thinking, Responsibility ~70-90.",
    ),
    
    # ========== IDENTIFICATION PILLAR ==========
    
    Task(
        id="cooking",
        name="Cooking (the visible bit)",
        pillar="identification",
        definition=(
            "This is the *doing* part — cooking the meals. It doesn't include deciding "
            "what to cook or building the shopping list (covered in Meal planning)."
        ),
        what_counts=[
            "Cooking on weekdays/weekends",
            "Warming/prepping for kids or different mealtimes",
            "Tidying as you go (if part of your norm)",
        ],
        note="If you alternate days, that's shared — use ~50.",
        example="If one partner cooks most weeknights, Responsibility might sit ~70–80.",
    ),
    
    Task(
        id="cleaning",
        name="Cleaning (routine)",
        pillar="identification",
        definition=(
            "Regular cleaning tasks and the *system* behind them (not occasional deep cleans unless that's your norm)."
        ),
        what_counts=[
            "Weekly surfaces, bathrooms, floors",
            "Small resets (dishes, counters, bins)",
            "Remembering consumables (sponges, sprays, bags)",
            "A loose rota/checklist if you use one",
        ],
        note="If one person sets the standard and nudges others, that's part of the load.",
        example="If you split weekends but one partner owns the standard, Responsibility ~60–70 to them.",
    ),
    
    Task(
        id="tidying",
        name="Tidying & decluttering",
        pillar="identification",
        definition=(
            "Noticing mess, clutter, and items out of place, and putting things back where they belong."
        ),
        what_counts=[
            "Picking up clothes, toys, items left around",
            "Putting things back in their proper places",
            "Decluttering surfaces and common areas",
            "Organising storage and cupboards",
        ],
        example="If one partner is constantly tidying up after everyone, Responsibility ~70-100.",
    ),
    
    Task(
        id="laundry",
        name="Laundry flow",
        pillar="identification",
        definition=(
            "Everything from noticing the hamper's full to finishing clean clothes in drawers. "
            "We're focusing on the *flow ownership* (who keeps it moving) rather than who folds once."
        ),
        what_counts=[
            "Noticing when to run loads; sorting/whites/darks",
            "Keeping machines cycling; moving wet clothes promptly",
            "Folding/hanging; putting away or delegating it",
            "Remembering school kits/sports days/uniforms",
        ],
        note="If one partner 'keeps it spinning' even if others help sometimes, weight toward that person.",
        example="If A notices and runs everything and B folds occasionally, Responsibility ~70–90 to A.",
    ),
    
    Task(
        id="home_maintenance",
        name="Home repairs & maintenance",
        pillar="identification",
        definition=(
            "Noticing when things break or need maintenance, and organising repairs or fixes."
        ),
        what_counts=[
            "Spotting broken items, leaks, things that need fixing",
            "Calling repair people, getting quotes",
            "Scheduling and coordinating home maintenance",
            "DIY repairs or organising someone to do them",
        ],
        example="If one partner notices and coordinates all repairs, Responsibility ~80-100.",
    ),
    
    # ========== DECISION PILLAR ==========
    
    Task(
        id="bills_admin",
        name="Bills & admin",
        pillar="decision",
        definition=(
            "Staying on top of finances and life admin so things don't lapse or get stressful."
        ),
        what_counts=[
            "Paying rent/mortgage, utilities, subscriptions",
            "Switching providers, renewals, comparisons",
            "Budgeting, expense tracking, filing receipts",
            "Chasing missing refunds/claims",
        ],
        note="Think 'headspace ownership' — who ensures this stays under control?",
        example="If one partner runs the calendar, reminders and switches, Responsibility ~70–100.",
    ),
    
    Task(
        id="appointments_health",
        name="Appointments & health",
        pillar="decision",
        definition=(
            "Booking, tracking and following up on healthcare or essential appointments for the household."
        ),
        what_counts=[
            "Booking GP/dentist/optician; tracking reminders",
            "Booking car service/repairs if you own one",
            "Following up on results, prescriptions, referrals",
            "Keeping the household calendar up to date",
        ],
        note="If one person handles most of the coordination, weight toward them.",
        example="If A books and tracks most appointments, Responsibility ~70–90.",
    ),
    
    Task(
        id="social_calendar",
        name="Social calendar & coordination",
        pillar="decision",
        definition=(
            "Managing the household's social life, coordinating schedules, and making social plans."
        ),
        what_counts=[
            "Coordinating family/couple social plans",
            "Managing conflicting schedules between household members",
            "Deciding on weekend plans or activities",
            "Organising when to see friends and family",
        ],
        example="If one partner coordinates most social planning, Responsibility ~70-90.",
    ),
    
    Task(
        id="kids_activities",
        name="Children's activities & hobbies",
        pillar="decision",
        requires_children=True,
        definition=(
            "Researching, choosing, and enrolling children in activities, hobbies, and clubs."
        ),
        what_counts=[
            "Researching options for activities/clubs/sports",
            "Deciding what children should participate in",
            "Enrolling and managing registrations",
            "Coordinating schedules and transport",
        ],
        example="If one partner researches and enrolls children in activities, Responsibility ~80-100.",
    ),
    
    # ========== MONITORING PILLAR ==========
    
    Task(
        id="kids_school",
        name="Children: school & schoolwork",
        pillar="monitoring",
        requires_children=True,
        definition=(
            "The orchestration behind school life — not the single pickup, but who keeps the whole system moving."
        ),
        what_counts=[
            "Remembering non-uniform days, forms, trips, fees",
            "Tracking homework and school projects",
            "Parent-teacher communication, emails, portals",
            "Monitoring children's academic progress",
        ],
        note="If you don't have children, this won't show.",
        example="If one partner is the default 'school admin', Responsibility tends to be high (e.g., 80–100).",
    ),
    
    Task(
        id="kids_health",
        name="Children's health & development",
        pillar="monitoring",
        requires_children=True,
        definition=(
            "Tracking children's health, development milestones, and medical needs."
        ),
        what_counts=[
            "Booking and attending children's health appointments",
            "Tracking vaccinations and health records",
            "Monitoring developmental milestones",
            "Noticing if children seem unwell or struggling",
        ],
        example="If one partner monitors and coordinates children's health, Responsibility ~80-100.",
    ),
    
    Task(
        id="household_calendar",
        name="Household calendar & coordination",
        pillar="monitoring",
        definition=(
            "Being the keeper of the family schedule and ensuring everyone knows where they need to be."
        ),
        what_counts=[
            "Maintaining the shared calendar",
            "Reminding others about upcoming appointments/events",
            "Coordinating who's picking up kids, who's cooking, etc.",
            "Ensuring conflicting commitments are resolved",
        ],
        example="If one partner is the 'calendar keeper', Responsibility ~80-100.",
    ),
    
    Task(
        id="food_waste",
        name="Food waste & leftovers",
        pillar="monitoring",
        definition=(
            "Tracking what food is in the fridge, using up leftovers, and preventing waste."
        ),
        what_counts=[
            "Checking what's in the fridge before it goes off",
            "Planning meals around leftovers",
            "Remembering to use ingredients before they expire",
            "Managing food storage and organisation",
        ],
        example="If one partner always knows what's in the fridge, Responsibility ~70-90.",
    ),
    
    Task(
        id="work_life_coordination",
        name="Work-life coordination",
        pillar="monitoring",
        requires_employment=True,
        definition=(
            "Managing the household around work schedules and coordinating when conflicts arise."
        ),
        what_counts=[
            "Tracking both partners' work schedules",
            "Adjusting household plans around work commitments",
            "Coordinating childcare/pickups when work runs late",
            "Managing household when one partner travels for work",
        ],
        example="If one partner does most of the 'work schedule tetris', Responsibility ~70-90.",
    ),
    
    # ========== EMOTIONAL PILLAR ==========
    
    Task(
        id="kids_emotional",
        name="Children's emotional wellbeing",
        pillar="emotional",
        requires_children=True,
        definition=(
            "Noticing and responding to children's emotional needs, worries, and struggles."
        ),
        what_counts=[
            "Checking in with children about their feelings",
            "Noticing when children seem upset or struggling",
            "Providing emotional support and reassurance",
            "Managing bedtime routines, soothing upsets",
        ],
        example="If one partner does most emotional check-ins, Responsibility ~80-100.",
    ),
    
    Task(
        id="relationship_maintenance",
        name="Relationship maintenance",
        pillar="emotional",
        definition=(
            "The work of maintaining your relationship - planning couple time, checking in emotionally."
        ),
        what_counts=[
            "Suggesting date nights or couple time",
            "Initiating conversations about the relationship",
            "Noticing when the relationship needs attention",
            "Remembering anniversaries and special occasions",
        ],
        example="If one partner usually suggests couple time, Responsibility ~70-90.",
    ),
    
    Task(
        id="family_relationships",
        name="Extended family relationships",
        pillar="emotional",
        definition=(
            "Managing relationships with extended family - remembering to call, organising visits, managing expectations."
        ),
        what_counts=[
            "Remembering to call/message parents, in-laws, relatives",
            "Organising family visits and gatherings",
            "Managing family expectations and conflicts",
            "Keeping family members updated on household news",
        ],
        example="If one partner manages most family communications, Responsibility ~80-100.",
    ),
    
    Task(
        id="household_mood",
        name="Household mood & atmosphere",
        pillar="emotional",
        definition=(
            "Managing the emotional atmosphere of the home - smoothing conflicts, creating positive moments."
        ),
        what_counts=[
            "Noticing when household tension is high",
            "Mediating conflicts between household members",
            "Creating positive moments (family activities, treats)",
            "Being the 'emotional thermostat' of the home",
        ],
        example="If one partner is the emotional manager, Responsibility ~80-100.",
    ),
    
    Task(
        id="partner_support",
        name="Partner emotional support",
        pillar="emotional",
        definition=(
            "Providing emotional support to your partner - listening, remembering their needs, checking in."
        ),
        what_counts=[
            "Remembering what's stressing your partner",
            "Asking how their day/work/life is going",
            "Providing emotional support and encouragement",
            "Noticing when your partner needs extra support",
        ],
        example="If one partner does most emotional checking-in, Responsibility ~70-90.",
    ),
]


TASK_LOOKUP: Dict[str, Task] = {t.id: t for t in TASKS}

def get_filtered_tasks(children: int, both_employed: bool) -> List[Task]:
    out: List[Task] = []
    for t in TASKS:
        if t.requires_children and children <= 0:
            continue
        if t.requires_employment and not both_employed:
            continue
        out.append(t)
    return out

def group_by_pillar(tasks: List[Task]) -> Dict[str, List[Task]]:
    d: Dict[str, List[Task]] = {}
    for t in tasks:
        d.setdefault(t.pillar, []).append(t)
    return d
----
utils/__init__.py

----
utils/dev_mode.py
# utils/dev_mode.py
import random
import streamlit as st
from tasks import get_filtered_tasks

def is_dev_mode():
    """Check if dev mode is enabled"""
    return st.session_state.get("dev_mode", False)

def toggle_dev_mode():
    """Toggle dev mode on/off"""
    st.session_state.dev_mode = not st.session_state.get("dev_mode", False)

def generate_sample_responses(scenario="balanced"):
    """
    Generate sample responses for testing
    
    Scenarios:
    - "balanced": Fairly even split (45-55 range)
    - "imbalanced": One partner carries most (70-90 range)
    - "mixed": Mix of balanced and imbalanced tasks
    - "random": Completely random
    """
    children = st.session_state.get("children", 0)
    both_employed = st.session_state.get("is_employed_me", True) and st.session_state.get("is_employed_partner", True)
    
    tasks = get_filtered_tasks(children, both_employed)
    responses = []
    
    for task in tasks:
        if scenario == "balanced":
            # Fairly balanced household
            responsibility = random.randint(40, 60)
            burden = random.randint(2, 4)
            fairness = random.randint(3, 5)
            
        elif scenario == "imbalanced":
            # Partner A carries most of the load
            responsibility = random.randint(10, 35)  # Partner A doing most
            burden = random.randint(3, 5)  # Higher burden
            fairness = random.randint(1, 3)  # Lower fairness
            
        elif scenario == "mixed":
            # Some balanced, some not
            if random.random() < 0.3:  # 30% imbalanced
                responsibility = random.choice([random.randint(10, 30), random.randint(70, 90)])
                burden = random.randint(3, 5)
                fairness = random.randint(2, 4)
            else:  # 70% balanced
                responsibility = random.randint(40, 60)
                burden = random.randint(2, 4)
                fairness = random.randint(3, 5)
                
        else:  # random
            responsibility = random.randint(0, 100)
            burden = random.randint(1, 5)
            fairness = random.randint(1, 5)
        
        responses.append({
            "task_id": task.id,
            "responsibility": responsibility,
            "burden": burden,
            "fairness": fairness,
            "not_applicable": False,
        })
    
    return responses

def populate_dev_data(scenario="balanced"):
    """Populate session state with dev data"""
    st.session_state.responses = generate_sample_responses(scenario)
    st.session_state.notes_by_section = {
        "anticipation": "Dev mode note: This section felt heavy",
        "emotional": "Dev mode note: Lots to discuss here",
    }
    st.success(f"✅ Dev mode: Populated {len(st.session_state.responses)} tasks with '{scenario}' scenario")

def dev_mode_widget():
    """Display dev mode controls in sidebar"""
    if not is_dev_mode():
        return
    
    st.sidebar.markdown("---")
    st.sidebar.markdown("### 🛠️ Dev Mode")
    
    col1, col2 = st.sidebar.columns(2)
    
    with col1:
        if st.sidebar.button("Balanced", use_container_width=True):
            populate_dev_data("balanced")
            st.rerun()
    
    with col2:
        if st.sidebar.button("Imbalanced", use_container_width=True):
            populate_dev_data("imbalanced")
            st.rerun()
    
    col3, col4 = st.sidebar.columns(2)
    
    with col3:
        if st.sidebar.button("Mixed", use_container_width=True):
            populate_dev_data("mixed")
            st.rerun()
    
    with col4:
        if st.sidebar.button("Random", use_container_width=True):
            populate_dev_data("random")
            st.rerun()
    
    if st.sidebar.button("Clear All Data", use_container_width=True):
        st.session_state.responses = []
        st.session_state.notes_by_section = {}
        st.success("✅ Cleared all data")
        st.rerun()
    
    st.sidebar.caption(f"📊 {len(st.session_state.get('responses', []))} tasks populated")
----
utils/ui.py
# utils/ui.py
import html
import streamlit as st
from typing import List, Optional

def _has_popover() -> bool:
    return hasattr(st, "popover")

def _esc(s: str) -> str:
    # Escape HTML so user text doesn’t break your markup
    return html.escape(s or "")

def step_header(title: str, subtitle: str = "", progress: int | None = None):
    st.markdown(f"### {title}")
    if subtitle:
        st.caption(subtitle)
    if isinstance(progress, int):
        st.progress(max(0, min(progress, 100)))

def learn_popover():
    ctx = st.popover("🔎 Learn / Help") if _has_popover() else st.expander("🔎 Learn / Help")
    with ctx:
        st.markdown("**What is mental load?**")
        st.write("The unseen planning, thinking and keeping-track work behind household life.")
        st.markdown("**What do sliders mean?**")
        st.write("- **Responsibility (0–100):** who mainly owns it (0 = Partner A, 100 = Partner B).")
        st.write("- **Burden (1–5):** how mentally taxing it feels.")
        st.write("- **Fairness (1–5):** how fair it feels right now.")
        st.markdown("**Tips for doing this together**")
        st.write("Talk as you go, keep it light, take a break if needed.")

def safety_note():
    st.info(
        "If anything here feels sensitive, pause and come back later. "
        "This tool is for a constructive chat, not for blame or therapy."
    )

def section_notes(key: str, placeholder: str = "Anything you noticed while answering…"):
    return st.text_area("📝 Notes for this section (optional)", key=key, height=100, placeholder=placeholder)

def tiny_hint(text: str):
    st.caption(text)

def explainer_block(title: str, bullets: List[str]):
    st.markdown(f"**{_esc(title)}**", unsafe_allow_html=True)
    for b in bullets:
        st.write(f"- {b}")

def definition_box(
    title: str,
    definition: str,
    what_counts: Optional[List[str]] = None,
    note: Optional[str] = None,
    example: Optional[str] = None,
):
    """Compact definition card used at the top of each task."""
    html_parts = [
        '<div class="card">',
        f'<div class="section-title">{_esc(title)}</div>',
        f'<p>{_esc(definition)}</p>',
    ]
    if what_counts:
        html_parts.append("<ul>")
        for item in what_counts:
            html_parts.append(f"<li>{_esc(item)}</li>")
        html_parts.append("</ul>")

    if example:
        html_parts.append(
            f'<div class="alert-info" style="margin-top:8px;"><strong>Example</strong><br>{_esc(example)}</div>'
        )

    if note:
        html_parts.append(
            f'<p style="color:#475569;margin-top:8px;"><small>{_esc(note)}</small></p>'
        )

    html_parts.append("</div>")
    st.markdown("".join(html_parts), unsafe_allow_html=True)

--END--
----
logic.py
from typing import List, Dict, Tuple
from models import Response

class Calculator:
    def __init__(self, responses: List[Response]):
        self.responses = [r for r in responses if not r.not_applicable]

    def _shares(self) -> Tuple[int,int]:
        # Invisible share: average responsibility across tasks
        if not self.responses:
            return 50, 50
        b_share = sum(r.responsibility for r in self.responses)/ (100*len(self.responses))
        a_pct = round((1 - b_share) * 100)
        b_pct = 100 - a_pct
        return a_pct, b_pct

    def _intensity(self) -> Tuple[int,int]:
        # Map burden (1..5) to 20..100 and weight by share
        if not self.responses: return 0,0
        def scale(b): return 20*b
        a_sum = 0.0; b_sum = 0.0; n = 0
        for r in self.responses:
            n += 1
            a_share = (100 - r.responsibility)/100
            b_share = r.responsibility/100
            a_sum += scale(r.burden) * a_share
            b_sum += scale(r.burden) * b_share
        return round(a_sum/n), round(b_sum/n)

    def pillar_scores(self) -> Dict[str, Tuple[float,float]]:
        d: Dict[str, Tuple[float,float]] = {}
        for r in self.responses:
            a_share = (100 - r.responsibility)/100
            b_share = r.responsibility/100
            a = d.get(r.task.pillar, (0.0,0.0))[0] + a_share*r.burden
            b = d.get(r.task.pillar, (0.0,0.0))[1] + b_share*r.burden
            d[r.task.pillar] = (a,b)
        return d

    def compute(self) -> Dict:
        a_pct, b_pct = self._shares()
        a_int, b_int = self._intensity()
        return dict(
            my_share_pct=a_pct, partner_share_pct=b_pct,
            my_intensity=a_int, partner_intensity=b_int,
            pillar_scores=self.pillar_scores()
        )

    @staticmethod
    def detect_hotspots(responses: List[Response]) -> List[Dict]:
        """
        Detect areas worth exploring in conversation.
        
        UPDATED LOGIC:
        - Responsibility imbalance (≥30 points from 50/50)
        - High burden (≥4 on 1-5 scale)
        - Low fairness (≤3 on 1-5 scale)
        - NEW: Combined flag for imbalance + unfairness
        """
        out = []
        for r in responses:
            reasons = []
            
            # Check responsibility imbalance
            responsibility_diff = abs(r.responsibility - 50)
            is_imbalanced = responsibility_diff >= 30
            
            # Check burden level
            is_high_burden = r.burden >= 4
            
            # Check fairness perception
            is_low_fairness = r.fairness <= 3
            
            # Flag different combinations
            if is_imbalanced:
                reasons.append("One partner handles most of this")
            
            if is_high_burden:
                reasons.append("This feels particularly draining")
            
            if is_low_fairness:
                reasons.append("This doesn't feel fair to one or both partners")
            
            # NEW: Special flag for imbalance + unfairness combo (Paul's request)
            if is_imbalanced and is_low_fairness:
                reasons.append("PRIORITY: Imbalanced AND feels unfair")
            
            # If any reasons flagged, add to hotspots
            if reasons:
                out.append({
                    "task": r.task.name,
                    "task_id": r.task.id,
                    "pillar": r.task.pillar,
                    "reasons": " | ".join(reasons),
                    "responsibility": r.responsibility,
                    "burden": r.burden,
                    "fairness": r.fairness,
                    # Add priority score for sorting
                    "priority": (
                        (responsibility_diff if is_imbalanced else 0) +
                        (r.burden * 10 if is_high_burden else 0) +
                        ((6 - r.fairness) * 15 if is_low_fairness else 0)
                    )
                })
        
        # Sort by priority (highest first)
        out.sort(key=lambda x: x.get("priority", 0), reverse=True)
        
        return out


# ==================================================
# HELPER FUNCTION - Convert reasons to questions
# ==================================================

def _reason_to_question(reasons: str) -> str:
    """Convert flagged reasons into conversation questions"""
    r = (reasons or "").lower()
    
    # Check for priority combo first
    if "priority" in r:
        return "This task is both imbalanced and feels unfair. What would make this feel more balanced or more fair for both of you?"
    
    # Check for individual flags
    if "imbalance" in r or "handles most" in r:
        return "How did this become one person's responsibility? Was it a deliberate choice, or did it just happen?"
    
    if "doesn't feel fair" in r or "unfair" in r:
        return "What would 'fair' look like to each of you for this task? What would need to change?"
    
    if "draining" in r or "burden" in r or "heavy" in r:
        return "What makes this task feel so heavy? Could part of it be shared, simplified, or done differently?"
    
    # Default question
    return "What's one small thing that might make this task easier or feel more balanced?"
----
models.py
from pydantic import BaseModel

# models.py (excerpt)
from dataclasses import dataclass, field
from typing import List, Optional

@dataclass
class Task:
    id: str
    name: str
    category: str = "household"
    pillar: str = "identification"    # or anticipation/decision/monitoring/emotional
    requires_children: bool = False
    requires_employment: bool = False
    requires_pets: bool = False  
    requires_vehicle: bool = False  

    # (all optional):
    definition: Optional[str] = None
    what_counts: Optional[List[str]] = field(default_factory=list)
    note: Optional[str] = None
    example: Optional[str] = None

class Response(BaseModel):
    task: Task
    responsibility: int          # 0..100 (0=A, 100=B)
    burden: int                  # 1..5
    fairness: int                # 1..5
    not_applicable: bool = False

----
requirements.txt
streamlit>=1.31
pydantic>=2.7
plotly>=5.24
pandas>=2.2

----
screens/__init__.py

----
screens/consent.py
import streamlit as st

def screen_consent():
    """
    Research consent screen with proper ethics information
    Replace [YOUR_EMAIL], [YOUR_UNIVERSITY], and [SUPERVISOR_NAME] with actual details
    """
    st.title("📋 Participant Information & Consent")
    st.caption("Research Study: Evaluating a Digital Tool for Mental Load Conversations")
    
    st.markdown("---")
    
    # Study information
    st.markdown("## About This Study")
    st.markdown("""
    You are invited to participate in a pilot study evaluating a digital tool designed to facilitate 
    conversations about mental load in cohabiting couples.
    
    **Principal Investigator:** Paul [YOUR_LAST_NAME]  
    **Institution:** [YOUR_UNIVERSITY]  
    **Supervisor:** [SUPERVISOR_NAME]  
    **Study Type:** Master's thesis pilot study
    """)
    
    st.markdown("---")
    
    # What participation involves
    with st.expander("📖 What does participation involve?"):
        st.markdown("""
        **Time commitment:** Approximately 30-40 minutes total
        
        **Activities:**
        1. **Pre-survey** (5 minutes): Complete individually before using the tool
        2. **Tool usage** (15-20 minutes): Complete the questionnaire together as a couple
        3. **Post-survey** (5-10 minutes): Complete individually after using the tool
        
        **What we're evaluating:**
        - Whether the tool is easy to use
        - Whether it facilitates productive conversations
        - Whether the results feel accurate and helpful
        
        **Important:** This study evaluates the tool itself, not your relationship or mental load patterns.
        """)
    
    # Privacy and data
    with st.expander("🔒 Privacy & Data Protection"):
        st.markdown("""
        **What data is collected:**
        - Your responses to pre- and post-surveys (stored in Google Forms)
        - Your questionnaire responses (only if you export the CSV)
        - No identifying information is collected
        
        **The tool itself stores NO data:**
        - Everything in the tool stays in your browser session
        - Data is deleted when you close the browser tab
        - Nothing is sent to any server
        
        **Survey data protection:**
        - Surveys use anonymous Couple IDs you create
        - No names, emails, or identifying information collected
        - Data stored securely in compliance with GDPR
        - Only the researcher and supervisor have access
        - Data will be deleted after thesis completion
        
        **Your Couple ID:**
        You'll create a unique code (like "BlueWhale42") to link your surveys without revealing your identity.
        """)
    
    # Rights
    with st.expander("✋ Your Rights"):
        st.markdown("""
        **Participation is completely voluntary:**
        - You can withdraw at any time without explanation
        - You can skip any questions you're uncomfortable with
        - You can stop using the tool at any point
        
        **No consequences for withdrawing:**
        - There is no penalty or disadvantage for not participating
        - You can request your data be deleted (using your Couple ID)
        
        **Contact information:**
        - Questions about the study: [YOUR_EMAIL]
        - Concerns about ethics: [UNIVERSITY_ETHICS_CONTACT if available]
        """)
    
    # Potential benefits and risks
    with st.expander("⚖️ Potential Benefits & Risks"):
        st.markdown("""
        **Potential benefits:**
        - Gain insight into mental load distribution in your household
        - Have structured conversations about invisible work
        - Receive research-backed conversation prompts
        - Contribute to research on household labour
        
        **Potential risks:**
        - Conversations about household labour may be sensitive
        - You might discover differences in perception
        - Discussions could bring up disagreements
        
        **Safeguards:**
        - The tool encourages kindness and pausing if needed
        - This is NOT a substitute for couples therapy
        - You can stop at any time
        - No pressure to complete if either partner feels uncomfortable
        """)
    
    st.markdown("---")
    
    # Important notes
    st.warning("""
    ⚠️ **This tool is for research purposes and is NOT:**
    - A diagnostic tool for relationship problems
    - A substitute for couples therapy or counselling
    - Professional psychological or medical advice
    
    If you're experiencing relationship distress, please seek support from a qualified professional.
    """)
    
    st.markdown("---")
    
    # Consent checkboxes
    st.markdown("## 🤝 Consent")
    st.markdown("Please confirm the following to participate:")
    
    consent_1 = st.checkbox(
        "I have read and understood the participant information above",
        key="consent_read"
    )
    
    consent_2 = st.checkbox(
        "I understand that participation is voluntary and I can withdraw at any time",
        key="consent_voluntary"
    )
    
    consent_3 = st.checkbox(
        "I understand how my data will be collected, stored, and used",
        key="consent_data"
    )
    
    consent_4 = st.checkbox(
        "I agree to participate in this research study",
        key="consent_participate"
    )
    
    consent_5 = st.checkbox(
        "My partner and I agree to complete this tool together in a respectful manner",
        key="consent_kind"
    )
    
    st.markdown("---")
    
    # Privacy reminder
    st.info("""
    🔒 **Privacy reminder:** This tool stores nothing. All data stays in your browser session. 
    Only the separate surveys (which you'll complete before and after) collect any information.
    """)
    
    # Navigation
    col1, col2 = st.columns(2)
    
    with col1:
        if st.button("← Back to Home", use_container_width=True):
            st.session_state.stage = "home"
            st.rerun()
    
    with col2:
        all_consents_given = all([consent_1, consent_2, consent_3, consent_4, consent_5])
        
        if st.button(
            "Continue to Setup →", 
            disabled=not all_consents_given,
            use_container_width=True,
            type="primary"
        ):
            st.session_state.stage = "setup"
            st.rerun()
        
        if not all_consents_given:
            st.caption("Please confirm all items above to continue")
----
screens/home.py
# screens/home.py
import streamlit as st

def screen_home():
    # Hero section - BIG and clear
    st.markdown("""
    <div style='text-align: center; padding: 60px 20px 40px;'>
        <h1 style='font-size: 3.5rem; font-weight: 800; margin-bottom: 1rem; line-height: 1.1;'>
            You can't share the load<br/>if it's invisible
        </h1>
        <p style='font-size: 1.4rem; color: #64748b; margin-bottom: 2rem; font-weight: 500;'>
            A 20-minute tool to make household mental work visible
        </p>
    </div>
    """, unsafe_allow_html=True)
    
    # Quick value props (visual cards) - ORIGINAL GRADIENTS
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>📊</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>See the split</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Who's carrying the invisible work?
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>💬</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>Talk it through</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Questions, not accusations
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div style='text-align: center; padding: 30px 20px; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); 
                    border-radius: 12px; color: white; min-height: 180px; display: flex; flex-direction: column; justify-content: center;'>
            <div style='font-size: 3rem; margin-bottom: 15px;'>🧪</div>
            <h3 style='font-size: 1.2rem; margin-bottom: 10px; color: white;'>Try one change</h3>
            <p style='font-size: 0.95rem; margin: 0; opacity: 0.95;'>
                Small experiments, not overhauls
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 50px 0 40px;'></div>", unsafe_allow_html=True)
    
    # How it works - PROFESSIONAL VERSION
    st.markdown("""
    <div style='text-align: center; margin-bottom: 30px;'>
        <h2 style='font-size: 2rem; font-weight: 700; margin-bottom: 10px;'>How It Works</h2>
        <p style='font-size: 1.1rem; color: #64748b;'>Three steps, approximately 20 minutes</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Three steps - ORIGINAL CIRCLES
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #3b82f6; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>1</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>Answer Together</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                Rate 20-25 household tasks on responsibility, burden, and fairness
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #8b5cf6; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>2</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>Review Results</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                Navigate through five pages of personalised insights
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    with col3:
        st.markdown("""
        <div style='text-align: center; padding: 20px;'>
            <div style='width: 60px; height: 60px; background: #10b981; color: white; border-radius: 50%; 
                        display: flex; align-items: center; justify-content: center; font-size: 1.5rem; 
                        font-weight: bold; margin: 0 auto 15px;'>3</div>
            <h3 style='font-size: 1.1rem; margin-bottom: 8px;'>Provide Feedback</h3>
            <p style='color: #64748b; font-size: 0.9rem; margin: 0;'>
                Complete a brief survey about your experience
            </p>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 60px 0 40px;'></div>", unsafe_allow_html=True)
    
    # NEW: Research context section
    st.markdown("## About This Research")
    st.info("""
    **Study Purpose:** This tool is being developed as part of a Master's thesis to explore 
    whether digital interventions can facilitate productive dialogue about household cognitive labour.
    
    **What We're Testing:** Whether this tool helps couples understand and discuss mental load, 
    not whether it measures or reduces mental load itself.
    
    **Your Role:** By participating, you're helping evaluate the tool's usability and effectiveness.
    """)
    
    st.markdown("<div style='margin: 40px 0;'></div>", unsafe_allow_html=True)
    
    # Key promises - ORIGINAL BOXES
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("""
        <div style='background: #f0fdf4; border: 2px solid #86efac; border-radius: 12px; padding: 25px;'>
            <h3 style='font-size: 1.1rem; margin-bottom: 15px; color: #166534;'>✅ What you'll get</h3>
            <ul style='margin: 0; padding-left: 20px; color: #334155;'>
                <li style='margin-bottom: 8px;'>Clear view of who's carrying what</li>
                <li style='margin-bottom: 8px;'>Research-backed conversation questions</li>
                <li style='margin-bottom: 8px;'>Personalised insights you can export</li>
                <li style='margin-bottom: 0;'>One actionable next step</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
    
    with col2:
        st.markdown("""
        <div style='background: #fffbeb; border: 2px solid #fde047; border-radius: 12px; padding: 25px;'>
            <h3 style='font-size: 1.1rem; margin-bottom: 15px; color: #854d0e;'>🔒 Privacy promise</h3>
            <ul style='margin: 0; padding-left: 20px; color: #334155;'>
                <li style='margin-bottom: 8px;'>No account or email required</li>
                <li style='margin-bottom: 8px;'>Data stays in your browser only</li>
                <li style='margin-bottom: 8px;'>Nothing sent to any server</li>
                <li style='margin-bottom: 0;'>Gone when you close the tab</li>
            </ul>
        </div>
        """, unsafe_allow_html=True)
    
    st.markdown("<div style='margin: 60px 0 30px;'></div>", unsafe_allow_html=True)
    
    # NEW: Important notes section
    st.warning("""
    **Please Note:**
    - This is a research tool, not a clinical instrument
    - Not a substitute for couples therapy or counselling
    - Results are based on your subjective perceptions
    - Pause if discussions become difficult
    """)
    
    # Pause warning - ORIGINAL
    st.warning("""
    ⏸️ **Pause if either of you is tired, stressed, or hungry right now.** This works best when you're both in a good headspace.
    """)
    
    st.markdown("<div style='margin: 30px 0;'></div>", unsafe_allow_html=True)
    
    # CTA - BIG button
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        if st.button("Begin Study →", use_container_width=True, type="primary"):
            st.session_state.stage = "consent"
            st.rerun()
        st.caption("20 minutes together • No data stored • Research-based")
    
    st.markdown("<div style='margin: 60px 0 20px;'></div>", unsafe_allow_html=True)
    
    # NEW: Research details and eligibility in expanders
    col1, col2 = st.columns(2)
    
    with col1:
        with st.expander("🎓 Research Information"):
            st.markdown("""
            **Researcher:** Paul Carmody
            **Institution:** University of Northumbria
            **Programme:** Master's in Computer Science with Data Analytics
            **Supervisor:** Dr. Naveed Anwar

            This study has received ethical approval.
            
            **Based on academic research:**
            - Daminger (2019): Cognitive dimensions of household labour
            - Hart & Staveland (1988): NASA-TLX workload assessment
            - Dean et al. (2022): Mental load and emotional labour
            """)
    
    with col2:
        with st.expander("❓ Who Can Participate?"):
            st.markdown("""
            **Inclusion Criteria:**
            - Cohabiting couples (any gender)
            - Both partners present and consenting
            - Able to complete in English
            - Access to computer/tablet
            
            **Not Suitable For:**
            - Couples in crisis
            - Those seeking clinical intervention
            - Single-person households
            """)
----
screens/learnmore.py
import streamlit as st

def screen_learn_more():
    st.header("Learn more — how this works")
    st.write("Plain-English overview of the science and design choices.")
    st.markdown("""
- **What we measure:** visible time and the *invisible* planning/monitoring/emotional work.
- **Why a quick estimate:** enough to surface patterns and start a caring conversation.
- **Fairness & care:** This isn’t a test. It’s a helper to agree small, practical changes.
    """)
    st.info("We’ll publish a methods note with sources as your thesis progresses.")

----
screens/questionnaire.py
# screens/questionnaire.py
import streamlit as st
from typing import Dict, List
from datetime import datetime

from tasks import get_filtered_tasks, group_by_pillar
from utils.ui import step_header, learn_popover, safety_note

# --------- Pillar context (conversational, research-grounded) ---------
PILLAR_INTRO: Dict[str, Dict[str, str]] = {
    "anticipation": {
        "title": "🔮 Anticipation: Thinking Ahead",
        "research": "Research identifies anticipation as one of four core dimensions of household cognitive labour (Daminger, 2019). This involves thinking ahead to what will be needed, often before anyone else notices.",
        "what_it_means": "This is the mental work of noticing what will be needed soon and planning for it before it becomes urgent.",
        "example": "Remembering the school form is due Friday, noticing you're low on milk, planning meals for the week."
    },
    "identification": {
        "title": "👁️ Identification: Noticing What Needs Doing",
        "research": "Identification refers to recognising what needs to be done and breaking it down into actionable tasks (Daminger, 2019). Studies show this 'noticing work' is often gendered and invisible to those not doing it.",
        "what_it_means": "This is the work of seeing what needs to happen and defining the actual tasks involved.",
        "example": "Spotting that the bathroom needs cleaning, recognising a child needs new shoes, seeing the light bulb is out."
    },
    "decision": {
        "title": "🤔 Decision-Making: Choosing How & When",
        "research": "Decision-making includes researching options, weighing trade-offs, and coordinating schedules (Daminger, 2019). This 'project management' work is often invisible yet cognitively demanding.",
        "what_it_means": "This is about making choices for the household - which doctor, what gift, how to handle a situation.",
        "example": "Choosing which childcare, deciding what to cook, picking a birthday gift, scheduling appointments."
    },
    "monitoring": {
        "title": "📋 Monitoring: Following Up & Tracking",
        "research": "Monitoring involves tracking whether tasks are completed and following up when needed (Daminger, 2019). Research emphasises this as a particularly invisible form of cognitive labour that can remain stressful even when tasks are delegated.",
        "what_it_means": "This is the work of tracking progress, remembering deadlines, and ensuring things don't fall through the cracks.",
        "example": "Checking if forms got submitted, following up on RSVPs, tracking when bills are due, reminding about tasks."
    },
    "emotional": {
        "title": "💝 Emotional Labour: The Caring Work",
        "research": "Emotional labour includes managing feelings, maintaining relationships, and creating household harmony (Dean, Churchill and Ruppanner, 2022). Research now recognises this as cognitive work, not simply 'being nice'.",
        "what_it_means": "This is about noticing and responding to others' feelings, maintaining family relationships, and creating a positive home environment.",
        "example": "Soothing upset children, remembering to call grandma, managing conflicts, creating special moments."
    }
}

# --------- Helper for task display ---------
def _render_task_card(task, default=None):
    """Simplified, conversation-focused task card"""
    
    # Task name as header
    st.markdown(f"### {task.name}")
    
    # Brief definition (not overwhelming)
    if task.definition:
        st.markdown(f"*{task.definition}*")
    
    # What counts (in a compact format)
    if task.what_counts:
        with st.expander("💡 What this includes"):
            for item in task.what_counts:
                st.markdown(f"• {item}")
    
    # Example if helpful
    if task.example:
        st.info(f"**Example:** {task.example}")
    
    st.markdown("")  # Spacing
    
    # Three questions, presented more conversationally
    st.markdown("**Answer these three questions together:**")
    
    col1, col2 = st.columns([3, 1])
    
    with col1:
        # ========== QUESTION 1: RESPONSIBILITY (UNCHANGED) ==========
        st.markdown("**1. Who mainly handles this right now?**")
        responsibility = st.slider(
            "Slide toward the person who carries most of this mental work",
            min_value=0, 
            max_value=100, 
            value=(default or {}).get("responsibility", 50),
            key=f"{task.id}_resp",
            help="0 = Partner A does all of it, 50 = shared equally, 100 = Partner B does all of it",
            label_visibility="collapsed"
        )
        
        # Visual label
        if responsibility < 30:
            st.caption("← Partner A handles most of this")
        elif responsibility > 70:
            st.caption("Partner B handles most of this →")
        else:
            st.caption("↔️ Shared fairly evenly")
        
        st.markdown("")
        
        # ========== QUESTION 2: BURDEN (NEW EXPLICIT WORDING) ==========
        st.markdown("**2. How mentally draining is this task?**")
        
        # Clarify whose burden to rate: the person who does most, or the typical experience if shared
        st.caption(
            "Please rate how mentally draining this task is for the person who does MOST of it (based on the slider). "
            "If you share it evenly, rate the typical experience or the average burden."
        )
        
        # Add visual guide based on responsibility slider
        if responsibility < 40:
            burden_caption = "Rate the burden experienced by Partner A (who handles most of this)"
        elif responsibility > 60:
            burden_caption = "Rate the burden experienced by Partner B (who handles most of this)"
        else:
            burden_caption = "Rate the typical/average burden when this is shared fairly evenly"
        
        st.caption(f"💭 *{burden_caption}*")
        
        burden = st.slider(
            "Burden level",
            min_value=1, 
            max_value=5, 
            value=(default or {}).get("burden", 3),
            key=f"{task.id}_burden",
            help="1 = Easy/light, 5 = Very draining",
            label_visibility="collapsed"
        )
        
        # Visual feedback
        burden_labels = {
            1: "😌 Light - barely think about it", 
            2: "🙂 Manageable - takes some mental energy", 
            3: "😐 Moderate - noticeable mental effort", 
            4: "😓 Heavy - quite draining", 
            5: "😰 Very draining - exhausting to manage"
        }
        st.caption(burden_labels.get(burden, ""))
        
        st.markdown("")
        
        # ========== QUESTION 3: FAIRNESS (NEW EXPLICIT WORDING) ==========
        st.markdown("**3. Does this current division feel fair to both of you?**")
        
        # NEW: Make fairness explicit and clarify what we're asking
        st.caption(
            "Even if one partner does more, it can still feel fair if both agree it makes sense. "
            "Rate how fair this current arrangement feels."
        )
        
        fairness = st.slider(
            "Fairness level",
            min_value=1, 
            max_value=5, 
            value=(default or {}).get("fairness", 3),
            key=f"{task.id}_fair",
            help="1 = Very unfair, 5 = Very fair",
            label_visibility="collapsed"
        )
        
        # Visual feedback with examples
        fairness_labels = {
            1: "😠 Very unfair - this really bothers us",
            2: "😕 Somewhat unfair - could be better",
            3: "😐 Neutral - it's okay for now",
            4: "🙂 Mostly fair - we're both comfortable with this",
            5: "😊 Very fair - we both feel good about how this is split"
        }
        st.caption(fairness_labels.get(fairness, ""))
        
        # Add helpful context
        st.caption(
            "💡 *Example: Partner A might do 80% of meal planning (high responsibility) "
            "but both partners think it's fair because Partner A enjoys it and Partner B "
            "handles other tasks. That would be rated 4-5 in fairness.*"
        )
        
        st.markdown("")
    
    with col2:
        # Not applicable checkbox
        not_applicable = st.checkbox(
            "This doesn't apply to us",
            value=(default or {}).get("not_applicable", False),
            key=f"{task.id}_na",
            help="Check this if this task is not relevant to your household"
        )
    
    return {
        "task_id": task.id,
        "responsibility": responsibility,
        "burden": burden,
        "fairness": fairness,
        "not_applicable": not_applicable,
    }




# --------- Main screen ---------
def screen_questionnaire():
    # Initialize state
    st.session_state.setdefault("q_pillar_index", 0)
    st.session_state.setdefault("responses", [])
    st.session_state.setdefault("notes_by_section", {})
    
    # Track start time (use .get to avoid KeyError if state wasn't initialised)
    if st.session_state.get('questionnaire_start_time') is None:
        st.session_state['questionnaire_start_time'] = datetime.now()

    # Get context
    children = st.session_state.get("children", 0)
    household_type = st.session_state.get("household_type", "couple")
    is_emp_me = st.session_state.get("is_employed_me", True)
    is_emp_partner = st.session_state.get("is_employed_partner", True) if household_type == "couple" else False
    both_employed = (is_emp_me and is_emp_partner) if household_type == "couple" else is_emp_me

    # Context flags (set in the Setup screen)
    has_pets = st.session_state.get('has_pets', False)
    has_vehicle = st.session_state.get('has_vehicle', False)

    tasks = get_filtered_tasks(children, both_employed, has_pets, has_vehicle)
    groups = group_by_pillar(tasks)

    # Pillar order
    ordered = ["anticipation", "identification", "decision", "monitoring", "emotional"]
    pillar_keys: List[str] = [k for k in ordered if k in groups] + [k for k in groups.keys() if k not in ordered]

    # Progress
    total_sections = len(pillar_keys)
    i = st.session_state.q_pillar_index
    progress = int((i / max(total_sections, 1)) * 100)

    # Header
    st.title("📝 Household Questionnaire")
    st.caption(f"Section {i+1} of {total_sections} • Talk it through together as you go")
    st.progress(progress)
    
    # Top navigation
    col1, col2, col3 = st.columns([1, 1, 1])
    with col1:
        if st.button("🏠 Home", use_container_width=True):
            st.session_state.stage = "home"
            st.rerun()
    with col2:
        learn_popover()
    with col3:
        if st.button("💾 Save & Exit", use_container_width=True):
            st.info("Your progress is saved in this session. You can return any time before closing the browser.")
            st.session_state.stage = "home"
            st.rerun()

    st.markdown("---")

    if not pillar_keys:
        st.warning("No tasks available for your context. Try adjusting Setup.")
        if st.button("← Back to Setup"):
            st.session_state.stage = "setup"
            st.rerun()
        return

    # Current pillar
    pillar = pillar_keys[i]
    pillar_info = PILLAR_INTRO.get(pillar, {})
    
    # Pillar introduction (research-grounded)
    st.markdown(f"## {pillar_info.get('title', pillar.capitalize())}")
    
    with st.expander("🎓 Why we're asking about this", expanded=(i == 0)):
        st.markdown(f"**What research shows:** {pillar_info.get('research', '')}")
        st.markdown(f"**What it means:** {pillar_info.get('what_it_means', '')}")
        st.markdown(f"**Example:** {pillar_info.get('example', '')}")
    
    st.markdown("---")
    
    # Gentle reminder
    if i == 0:
        st.info("💙 **Remember:** There are no right answers. Just your honest experience right now. Take breaks if you need them.")
    
    # Tasks in this section
    section_tasks = groups[pillar]
    st.markdown(f"### {len(section_tasks)} tasks in this section")
    st.caption("For each task, answer together. It's okay to disagree - note different perspectives at the bottom.")
    
    st.markdown("---")
    
    # Render tasks
    updated = []
    for idx, t in enumerate(section_tasks, 1):
        st.markdown(f"#### Task {idx} of {len(section_tasks)}")
        prev = next((r for r in st.session_state.responses if r["task_id"] == t.id), None)
        resp = _render_task_card(t, default=prev)
        updated.append(resp)
        st.markdown("---")

    # Merge updates
    other = [r for r in st.session_state.responses if r["task_id"] not in {t.id for t in section_tasks}]
    st.session_state.responses = other + updated

    # Notes for this section
    st.markdown("### 📝 Notes for this section (optional)")
    st.caption("Different perspectives? Something that felt particularly heavy? An idea to try? Jot it down.")
    
    note_key = f"notes_{pillar}"
    existing_note = st.session_state.notes_by_section.get(pillar, "")
    
    new_note = st.text_area(
        "Your notes:",
        value=existing_note,
        height=100,
        placeholder="E.g., 'Partner A didn't realise Partner B was tracking all the meal planning' or 'We both want to try meal-prepping on Sundays'",
        key=note_key,
        help="These notes stay in your browser session and can be exported with your results."
    )
    st.session_state.notes_by_section[pillar] = new_note

    # Navigation
    st.markdown("---")
    st.markdown("### Ready to continue?")
    
    colA, colB, colC = st.columns([1, 1, 2])
    with colA:
        if st.button("⬅️ Previous Section", disabled=(i == 0), use_container_width=True):
            if i > 0:
                st.session_state.q_pillar_index = i - 1
                st.rerun()
    with colB:
        if i < total_sections - 1:
            if st.button("Next Section ➡️", use_container_width=True, type="primary"):
                st.session_state.q_pillar_index = i + 1
                st.rerun()
        else:
            if st.button("See Results →", use_container_width=True, type="primary"):
                if not st.session_state.responses:
                    st.warning("Please answer at least one task first.")
                else:
                    # Calculate completion time
                    start = st.session_state.get('questionnaire_start_time')
                    if start:
                        completion_time = (datetime.now() - start).total_seconds()
                        st.session_state['completion_time_seconds'] = completion_time
                    
                    st.session_state.results_prep_seen = False
                    st.session_state.stage = "results"
                    st.rerun()
    
    with colC:
        # Progress indicator
        completed = sum(1 for r in st.session_state.responses if not r.get("not_applicable", False))
        total_tasks = len(tasks)
        st.caption(f"📊 Progress: {completed} of {total_tasks} tasks completed")
----
screens/results.py
# screens/results.py
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from typing import Dict, List
import logging

from state import reset_state
from tasks import TASK_LOOKUP
from models import Response
from logic import Calculator

# Set up error logging
logging.basicConfig(level=logging.ERROR)
logger = logging.getLogger(__name__)

A_COL = "#0072B2"  # Okabe–Ito blue (Partner A)
B_COL = "#E69F00"  # Okabe–Ito orange (Partner B)
GRID = "rgba(0,0,0,0.08)"

PILLAR_ORDER = ["anticipation", "identification", "decision", "monitoring", "emotional"]
PILLAR_LABELS = {
    "anticipation": "Anticipation",
    "identification": "Identification",
    "decision": "Decision",
    "monitoring": "Monitoring",
    "emotional": "Emotional",
}

# ---------- utils ----------
def _to_response_objects(response_dicts):
    objs = []
    for r in response_dicts:
        task = TASK_LOOKUP.get(r["task_id"])
        if not task:
            continue
        objs.append(
            Response(
                task=task,
                responsibility=int(r["responsibility"]),
                burden=int(r["burden"]),
                fairness=int(r["fairness"]),
                not_applicable=bool(r.get("not_applicable", False)),
            )
        )
    return objs

def _ensure_all_pillars(scores: Dict[str, List[float]]) -> Dict[str, List[float]]:
    """Guarantee all five pillars exist; fill missing with zeros."""
    out = {}
    for k in PILLAR_ORDER:
        out[k] = list(scores.get(k, [0.0, 0.0]))
        if len(out[k]) != 2:
            out[k] = [0.0, 0.0]
    return out

def _plain_reason(raw: str) -> str:
    """Convert technical reasons to plain language"""
    s = raw or ""
    # Remove PRIORITY tag for display
    s = s.replace("PRIORITY: ", "")
    s = s.replace("Responsibility imbalance (≥30 pts)", "One partner is handling most of this")
    s = s.replace("One partner handles most of this", "One partner is handling most of this")
    s = s.replace("High burden", "This feels particularly draining")
    s = s.replace("Low perceived fairness", "This doesn't feel fair to one or both partners")
    s = s.replace("This feels particularly draining", "Rated as mentally draining")
    s = s.replace("Imbalanced AND feels unfair", "Both imbalanced and feels unfair")
    return s

def _reason_to_question(reasons: str) -> str:
    """Convert reasons into conversation questions"""
    r = (reasons or "").lower()
    if "lopsided" in r or "imbalance" in r or "handling most" in r:
        return "How did this become one person's responsibility? Was it a deliberate choice?"
    if "doesn't feel fair" in r or "fairness" in r:
        return "What would 'fair' look like to each of you for this task?"
    if "heavy" in r or "burden" in r or "draining" in r:
        return "What makes this task feel so heavy? Could part of it be shared or simplified?"
    return "What's one small thing that might make this easier?"

# ---------- visuals ----------
def comparison_bars(a_val: int, b_val: int, max_val: int = 100, label_a="Partner A", label_b="Partner B"):
    """Simple horizontal comparison bars"""
    fig = go.Figure()
    
    fig.add_trace(go.Bar(
        y=[label_a, label_b],
        x=[a_val, b_val],
        orientation='h',
        marker=dict(color=[A_COL, B_COL]),
        text=[f"{a_val}", f"{b_val}"],
        textposition='outside',
        textfont=dict(size=20, color='black'),
    ))
    
    fig.update_layout(
        height=150,
        margin=dict(l=120, r=60, t=10, b=10),
        xaxis=dict(range=[0, max_val], showgrid=False, showticklabels=False),
        yaxis=dict(showgrid=False),
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)',
        showlegend=False,
    )
    
    return fig

def pillar_grouped_bar(pillar_scores: Dict[str, List[float]]) -> go.Figure:
    scores = _ensure_all_pillars(pillar_scores)
    rows = []
    for k in PILLAR_ORDER:
        a, b = scores[k]
        rows.append({"Pillar": PILLAR_LABELS[k], "Partner": "A", "Score": a})
        rows.append({"Pillar": PILLAR_LABELS[k], "Partner": "B", "Score": b})
    df = pd.DataFrame(rows)
    df["Pillar"] = pd.Categorical(df["Pillar"], categories=[PILLAR_LABELS[k] for k in PILLAR_ORDER], ordered=True)

    fig = px.bar(
        df.sort_values("Pillar"),
        x="Pillar", y="Score", color="Partner",
        barmode="group", template="simple_white",
        color_discrete_map={"A": A_COL, "B": B_COL},
    )
    fig.update_layout(
        height=300,
        margin=dict(l=10, r=10, t=10, b=10),
        legend=dict(orientation="h", y=1.08, x=0.0),
    )
    fig.update_xaxes(showgrid=False, ticks="")
    fig.update_yaxes(gridcolor=GRID, zeroline=False, title="")
    return fig

# ---------- CSV export ----------
def _export_csv(responses, results, hotspots):
    df = pd.DataFrame(responses)
    csv = df.to_csv(index=False)

    summary = pd.DataFrame(
        {
            "Metric": [
                "Partner A load (0–100)",
                "Partner B load (0–100)",
                "Partner A invisible share (%)",
                "Partner B invisible share (%)",
            ],
            "Value": [
                results["my_intensity"],
                results["partner_intensity"],
                results["my_share_pct"],
                results["partner_share_pct"],
            ],
        }
    )
    # If we have a recorded completion time, include it in the summary
    try:
        import streamlit as _st
        completion = _st.session_state.get("completion_time_seconds")
        if completion is not None:
            # Add as minutes:seconds for readability
            mins = int(completion // 60)
            secs = int(completion % 60)
            summary = pd.concat(
                [summary, pd.DataFrame({"Metric": ["Questionnaire time (mm:ss)"], "Value": [f"{mins}m {secs}s"]})],
                ignore_index=True,
            )
    except Exception:
        # Fail quietly if session_state isn't available for some reason
        pass
    csv += "\n\nSUMMARY\n" + summary.to_csv(index=False)

    p = _ensure_all_pillars(results.get("pillar_scores", {}))
    p_rows = [{"Pillar": PILLAR_LABELS[k], "Partner A sum": round(v[0], 2), "Partner B sum": round(v[1], 2)} for k, v in p.items()]
    csv += "\n\nPILLAR BREAKDOWN\n" + pd.DataFrame(p_rows).to_csv(index=False)

    if hotspots:
        hs_rows = [{"Task": h.get("task", ""), "Why it matters": _plain_reason(h.get("reasons", "")), "Question to discuss": _reason_to_question(h.get("reasons", ""))} for h in hotspots]
        csv += "\n\nCONVERSATION STARTERS\n" + pd.DataFrame(hs_rows).to_csv(index=False)

    return csv


def _add_notes_section(page_name: str):
    """Render a small notes area for a results page and persist notes in session state.

    Notes are stored in st.session_state['results_notes'] as a mapping from page name
    to the note text. This keeps notes available for export or later review.
    """
    st.markdown("---")
    st.markdown("### Notes (optional)")
    st.caption(" jot down reflections, actions to try, or anything to follow up on.")

    # Ensure the container exists
    if "results_notes" not in st.session_state:
        st.session_state["results_notes"] = {}

    key = f"results_notes_{page_name.replace(' ', '_').lower()}"
    existing = st.session_state["results_notes"].get(page_name, "")

    new_note = st.text_area(
        "Your notes:",
        value=existing,
        height=120,
        placeholder="E.g., 'Try meal-planning on Sundays' or 'Discuss monitoring tasks next week'",
        key=key,
    )

    # Persist back to the dictionary
    st.session_state["results_notes"][page_name] = new_note


# ---------- conversation prep screen ----------
def screen_before_results():
    """Pre-results conversation guide"""
    st.title("💬 Before You See Your Results")
    st.markdown("### A few minutes to prepare for a productive conversation")
    
    st.markdown("""
    You're about to see data about mental load in your household. This can bring up big feelings - 
    that's completely normal and actually a sign you're both invested in your partnership.
    """)
    
    st.markdown("---")
    
    st.markdown("### 🎓 What Research Tells Us")
    st.info("""
    **Mental load** (also called cognitive labour) is the invisible work of managing a household: 
    anticipating needs, making decisions, tracking details, and coordinating family life.
    
    Research consistently shows:
    - This work is often invisible to the person not doing it
    - In heterosexual couples, women typically carry 70-80% of this load
    - It's **not about time spent** - it's about the mental energy of being "on call"
    - Even in couples who split visible tasks 50/50, mental load is often imbalanced
    - The biggest predictor of relationship satisfaction isn't perfect equality - it's feeling **heard and understood**
    """)
    
    st.markdown("### 🤝 Ground Rules for This Conversation")
    st.success("""
    **Do:**
    - Assume good intentions
    - Listen to understand, not to defend
    - Notice what surprises you
    - Acknowledge the other person's feelings as valid
    - Take breaks if it gets intense
    
    **Don't:**
    - Keep score or bring up past grievances  
    - Interrupt or dismiss
    - Try to "win" the conversation
    - Expect to solve everything today
    """)
    
    st.markdown("### 🎯 The Goal of This Exercise")
    st.markdown("""
    The point isn't to create perfect 50/50 splits or to prove who's right. 
    
    **The goal is to:**
    1. Make invisible work visible
    2. Understand each other's experience
    3. Find 1-2 small changes you both agree to try
    4. Build a habit of checking in together
    """)
    
    st.markdown("---")
    
    st.markdown("### ✋ Before You Continue")
    st.warning("""
    **Pause here if:**
    - Either of you is tired, hungry, or stressed right now
    - You've been arguing about this recently
    - One of you isn't ready to have this conversation
    
    This tool will be here when you're both ready. There's no rush.
    """)
    
    st.markdown("---")
    
    col1, col2 = st.columns(2)
    with col1:
        if st.button("← Back to questionnaire", use_container_width=True):
            st.session_state.stage = "questionnaire"
            st.rerun()
    with col2:
        if st.button("We're ready - show results →", use_container_width=True, type="primary"):
            st.session_state.results_page = 1
            st.session_state.stage = "results_main"
            st.rerun()

# ---------- PAGINATED RESULTS SECTIONS ----------

def _results_page_1_share(results, hotspots):
    """Page 1: The Big Picture - Who's Carrying What"""
    st.title("📊 Your Results: The Big Picture")
    st.caption("💙 Remember: This is about understanding, not blame.")
    st.progress(20)  # 1 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 📚 Context: What Research Shows")
    
    with st.expander("📖 Click to read about mental load patterns in households"):
        st.markdown("""
        Studies of household labour consistently find:
        
        - **Visible vs. Invisible Split:** Even when couples split physical tasks evenly, the invisible work 
          (planning, remembering, coordinating) is often held by one partner
        - **The "Manager-Helper" Dynamic:** One partner acts as the household manager who delegates, 
          while the other helps when asked - but doesn't carry the mental burden of anticipating needs
        - **Gendered Patterns:** In heterosexual couples, research shows women typically carry 2-3x 
          more cognitive labour, regardless of employment status
        - **Why It Matters:** Unacknowledged mental load is strongly linked to resentment, burnout, 
          and relationship dissatisfaction
        - **Good News:** Simply naming and discussing mental load improves outcomes, even before changes are made
        """)
    
    st.markdown("### 🔍 Your Household's Snapshot")
    st.markdown("Here's what your responses show about mental load distribution right now.")
    
    a_share, b_share = results["my_share_pct"], results["partner_share_pct"]
    
    # Share percentages
    st.markdown("**Mental load share (who's carrying the invisible work):**")
    st.plotly_chart(comparison_bars(a_share, b_share, 100, "Partner A", "Partner B"), use_container_width=True)
    
    # Research context for their numbers
    diff = abs(a_share - b_share)
    if diff <= 15:
        st.success("✅ **Your household shows relatively balanced mental load.** Research suggests 60/40 or closer is associated with higher relationship satisfaction.")
    elif diff <= 30:
        st.info("📊 **Your split is common.** About 60% of couples show this pattern. The question is: does it feel sustainable to both of you?")
    else:
        st.warning("📊 **This pattern is common but can lead to burnout.** Research shows splits beyond 70/30 often predict resentment over time - but this is changeable.")
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - Does this percentage match how it *feels* in daily life?
    - What surprises you about this number?
    - What might explain this pattern in your household?
    """)


def _results_page_2_burden(results):
    """Page 2: How Heavy Does It Feel"""
    st.title("📊 How Heavy Does It Feel?")
    st.caption("💙 Understanding the emotional weight of invisible work")
    st.progress(40)  # 2 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 😰 Personal Burden")
    st.markdown("""
    **Personal burden (1-5 scale):** This isn't about how much time tasks take - it's about how draining 
    the mental work feels.
    
    Research shows mental load burden comes from:
    - Being "on call" mentally even during downtime
    - The invisible work of anticipating others' needs
    - Carrying responsibility without recognition
    """)
    
    a_int, b_int = results["my_intensity"], results["partner_intensity"]
    
    # Normalize intensity values to a 1-5 scale before converting to 0-100 for visuals.
    # Some stored values may be scaled (e.g. 29 meaning 2.9); handle that consistently.
    def _normalize_int(v):
        try:
            v = float(v)
        except Exception:
            return 3.0
        # If value looks like it's scaled by 10 (e.g. 29 -> 2.9), convert
        if v > 5 and v <= 50:
            v = v / 10.0
        # Clamp to 1-5
        if v < 1:
            v = 1.0
        if v > 5:
            v = 5.0
        return v

    a_norm = _normalize_int(a_int)
    b_norm = _normalize_int(b_int)

    # Convert normalized 1-5 to 0-100 for display (1->0, 3->50, 5->100)
    a_int_display = round((a_norm - 1) / 4 * 100)
    b_int_display = round((b_norm - 1) / 4 * 100)
    
    st.plotly_chart(comparison_bars(a_int_display, b_int_display, 100, "Partner A", "Partner B"), use_container_width=True)
    
    # Show actual scores below chart
    col1, col2 = st.columns(2)
    with col1:
        # Format intensity for display: if values are larger than 5 they may be scaled
        # (e.g. 29 meaning 2.9); present a friendly average on a 1-5 scale and include
        # the raw value for transparency.
        def _fmt_intensity(v):
            try:
                v = float(v)
            except Exception:
                return str(v)
            if v <= 5:
                return f"{v:.1f}/5" if (v != int(v)) else f"{int(v)}/5"
            # if value looks like it's scaled by 10 (e.g. 29 -> 2.9)
            if 5 < v <= 50:
                avg = v / 10.0
                return f"{avg:.1f}/5 ({int(v)})"
            # fallback: show raw numeric
            return f"{v}"

        st.metric("Partner A Intensity", _fmt_intensity(a_int))
    with col2:
        st.metric("Partner B Intensity", _fmt_intensity(b_int))
    
    # Research context
    load_diff = abs(a_int - b_int)
    if load_diff <= 1.0:
        st.success("Both partners report similar burden levels - this suggests the mental energy feels fairly distributed.")
    elif load_diff <= 2.0:
        heavier = "Partner A" if a_int > b_int else "Partner B"
        st.info(f"📊 {heavier} reports feeling more burdened. This is worth exploring - sometimes visible task-sharing doesn't capture invisible stress.")
    else:
        heavier = "Partner A" if a_int > b_int else "Partner B"
        st.warning(f"⚠️ {heavier}'s burden score is notably higher. Research links sustained high burden to burnout and relationship strain.")
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - For the person with higher burden: What makes it feel heavy? Is it the tasks themselves, or the mental energy of managing them?
    - For the person with lower burden: Does this surprise you? What might you not be seeing?
    - Are there times of day or week when burden peaks for each of you?
    """)


def _results_page_3_pillars(results):
    """Page 3: The Five Pillars"""
    st.title("📊 Where the Mental Load Lives")
    st.caption("💙 Breaking down the five types of invisible work")
    st.progress(60)  # 3 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 🏛️ The Five Pillars of Mental Load")
    st.markdown("""
    Research identifies five types of cognitive labour in households. This chart shows which 
    partner is carrying more of each type.
    """)
    
    with st.expander("ℹ️ What these five pillars mean (click to expand)"):
        st.markdown("""
        Based on research in household labour and emotional work:
        
        - **Anticipation:** Thinking ahead to what will be needed (meal planning, remembering appointments, 
          anticipating when supplies run low)
        - **Identification:** Noticing what needs doing (seeing the mess, recognising when something's broken, 
          spotting when someone needs support)
        - **Decision-Making:** Researching options and making choices (which doctor, what gift, how to handle 
          a situation)
        - **Monitoring:** Tracking progress and following up (did the form get submitted? Is the kids' project 
          done? Are we running low on groceries?)
        - **Emotional Labour:** Managing feelings, maintaining relationships, providing support, creating 
          household harmony
        
        **Key finding:** The monitoring and anticipation pillars are often most invisible to the partner not doing them.
        """)
    
    pillar_scores = _ensure_all_pillars(results.get("pillar_scores", {}))
    st.plotly_chart(pillar_grouped_bar(pillar_scores), use_container_width=True)
    
    # Discussion prompt
    st.markdown("---")
    st.markdown("### 💭 Pause & Reflect")
    st.markdown("""
    **Questions to discuss together:**
    - Which pillar shows the biggest difference between you?
    - Is there a pillar where one person didn't realise how much the other was doing?
    - Research shows "monitoring" is often invisible - does that resonate?
    """)


def _results_page_4_hotspots(hotspots):
    """Page 4: Topics to Explore (UPDATED WORDING)"""
    st.title("📊 Topics to Explore Together")  # CHANGED from "Conversation Starters"
    st.caption("💙 Areas where your responses suggest room for discussion")  # CHANGED caption
    st.progress(80)  # 4 of 5 pages
    
    st.markdown("---")
    
    st.markdown("## 💬 Areas Worth Discussing")  # CHANGED from "Areas to Explore"
    st.markdown("""
    These aren't "problems to fix" — they're **topics worth exploring together**. 
    
    Research shows that couples who regularly discuss mental load (even without making immediate changes) 
    report higher satisfaction than those who don't talk about it. Simply having the conversation is valuable.
    """)
    
    if hotspots:
        # UPDATED: Show priority items first
        priority_items = [h for h in hotspots if "PRIORITY" in h.get("reasons", "")]
        regular_items = [h for h in hotspots if "PRIORITY" not in h.get("reasons", "")]
        
        # Show priority items with special formatting
        if priority_items:
            st.warning(f"🔴 **{len(priority_items)} priority topic(s)** flagged: Both imbalanced AND perceived as unfair")
            st.caption("These combinations often indicate areas where change would be most impactful.")
            
            for i, h in enumerate(priority_items, 1):
                with st.container():
                    st.markdown(f"### 🔴 Priority {i}: {h.get('task', 'Task')}")
                    
                    col1, col2 = st.columns([1, 1])
                    with col1:
                        st.markdown(f"**Current split:** {h.get('responsibility', 50)}% to one partner")
                        st.markdown(f"**Burden level:** {h.get('burden', 3)}/5")
                        st.markdown(f"**Fairness rating:** {h.get('fairness', 3)}/5")
                    
                    with col2:
                        question = _reason_to_question(h.get("reasons", ""))
                        st.markdown(f"**💭 Discuss:** {question}")
                    
                    st.markdown("")
            
            st.markdown("---")
        
        # Show regular hotspots
        if regular_items:
            st.info(f"📌 {len(regular_items)} additional area(s) to explore")
            
            # Show top 3 regular items
            for i, h in enumerate(regular_items[:3], 1):
                with st.container():
                    st.markdown(f"### {i}. {h.get('task', 'Task')}")
                    
                    col1, col2 = st.columns([1, 1])
                    with col1:
                        # Clean up reason text (remove "One partner handles most" etc)
                        plain = _plain_reason(h.get("reasons", ""))
                        st.markdown(f"**Why flagged:** {plain}")
                    
                    with col2:
                        question = _reason_to_question(h.get("reasons", ""))
                        st.markdown(f"**💭 Discuss:** {question}")
                    
                    st.markdown("")
            
            # Remaining in expander
            if len(regular_items) > 3:
                with st.expander(f"📋 See {len(regular_items) - 3} more topics"):
                    for i, h in enumerate(regular_items[3:], 4):
                        st.markdown(f"**{i}. {h.get('task', 'Task')}**")
                        st.markdown(f"*{_plain_reason(h.get('reasons', ''))}*")
                        st.markdown(f"💭 *{_reason_to_question(h.get('reasons', ''))}*")
                        st.markdown("")
    else:
        st.success("""
        🎉 **No major topics flagged!** 
        
        Your responses suggest relatively balanced mental load distribution, and the tasks that are 
        imbalanced are generally perceived as fair. This is worth celebrating!
        
        Still, research recommends checking in periodically - life circumstances change, and what works 
        now might need adjustment later. Consider using this tool again in 3-6 months.
        """)
    
    # Optional notes
    st.markdown("---")
    _add_notes_section("Page 4: Topics to Explore")



def _results_page_5_action():
    """Page 5: What's Next"""
    st.title("📊 What's Next")
    st.caption("💙 Building from strengths and trying small experiments")
    st.progress(100)  # 5 of 5 pages
    
    # Show a prominent, static display of how long the questionnaire took (no running timers)
    completion_secs = st.session_state.get("completion_time_seconds")
    if completion_secs is None and st.session_state.get("questionnaire_start_time"):
        try:
            from datetime import datetime
            completion_secs = (datetime.now() - st.session_state["questionnaire_start_time"]).total_seconds()
            st.session_state["completion_time_seconds"] = completion_secs
        except Exception:
            completion_secs = None

    if completion_secs is not None:
        mins = int(completion_secs // 60)
        secs = int(completion_secs % 60)
        # Large, centered time display for emphasis
        st.markdown(
            f"<div style='text-align:center; margin: 12px 0;'>"
            f"<div style='font-size:28px; font-weight:800;'>⏱️ {mins}m {secs}s</div>"
            f"<div style='color:#475569; margin-top:6px;'>Time taken to complete the questionnaire</div>"
            f"</div>",
            unsafe_allow_html=True,
        )
    
    st.markdown("---")
    
    # ====== WHAT'S WORKING ======
    st.markdown("## ✨ What's Working Well")
    st.markdown("""
    Research on couple interventions shows that building from strengths is more effective than 
    only focusing on problems.
    """)
    
    # Find areas of relative balance
    balanced_areas = []
    for task_response in st.session_state.responses:
        resp_diff = abs(task_response.get("responsibility", 50) - 50)
        if resp_diff <= 20 and task_response.get("burden", 50) < 60:
            task = TASK_LOOKUP.get(task_response["task_id"])
            if task:
                balanced_areas.append(task.name)
    
    if balanced_areas:
        st.success(f"**Areas showing good balance:** {', '.join(balanced_areas[:5])}")
        st.markdown("💭 **Discuss:** What makes these areas work well? Can you apply that pattern elsewhere?")
    else:
        st.info("**Every household has strengths.** What's one thing you're both proud of in how you manage your home together?")
    
    st.markdown("---")
    
    # ====== EXPERIMENT ======
    st.markdown("## 🧪 Try One Small Experiment")
    st.markdown("""
    Research on behaviour change shows that small, time-bound experiments work better than big overhauls.
    
    **The invitation:** Pick ONE thing from your conversation starters. Agree to try a small change 
    for one week, then check in.
    """)
    
    st.info("""
    **What makes a good experiment:**
    - Specific (not "help more" but "Partner B will plan meals Tuesday-Thursday")
    - Time-bound (try for one week)
    - Agreed by both (not imposed on one person)
    - Reversible (you can always go back)
    """)
    
    st.markdown("---")
    st.markdown("## 🎉 You've Completed the Tool")
    st.success("""
    **Thank you for using the Mental Load Coach!**
    
    You've taken an important step toward understanding mental load in your household.
    """)
    
    st.markdown("---")
    
    # ====== SURVEY LINK ======
    st.markdown("## 📋 Important: Post-Session Survey")

    st.info("""
    Please complete a short survey now while this session is fresh in your mind.

    The survey takes about 5 minutes and helps us understand whether the tool was useful and which
    suggestions participants are likely to try.(Key for research!)
    """)

    # Office Forms link provided by the researcher
    survey_url = "https://forms.office.com/e/jM0DXUg1vV"

    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        st.link_button(
            "📋 Complete the quick survey now →",
            survey_url,
            use_container_width=True,
            type="primary"
        )

    st.caption("Takes ~5 minutes • Your immediate feedback is invaluable for the research")

    st.markdown("---")

    st.markdown("""
    **Next steps:**
    - Download your results for reference (button at top)
    - Try your small experiment for one week
    - Complete the short survey now
    - Return to this tool in a month to see how things have shifted
    """)


# ---------- main results navigation ----------
def screen_results_main():
    """Main results with pagination"""
    
    if not st.session_state.get("responses"):
        st.warning("No results yet. Please complete the questionnaire first.")
        if st.button("← Return to Questionnaire", use_container_width=True):
            st.session_state.stage = "questionnaire"
            st.rerun()
        return

    # Compute results with error handling
    try:
        response_objs = _to_response_objects(st.session_state.responses)
        
        if not response_objs:
            st.error("No valid responses found. Please complete at least one task.")
            if st.button("← Return to Questionnaire", use_container_width=True):
                st.session_state.stage = "questionnaire"
                st.rerun()
            return
        
        calc = Calculator(response_objs)
        results = calc.compute()
        hotspots = Calculator.detect_hotspots(response_objs)
        
    except Exception as e:
        st.error(f"""
        **Error Processing Results**
        
        We encountered an error: {str(e)}
        
        Please try:
        1. Refreshing the page
        2. Using a different browser
        3. Contacting the researcher: [ADD YOUR EMAIL]
        """)
        logger.error(f"Results error: {str(e)}", exc_info=True)
        return

    # Initialize page if not set
    if "results_page" not in st.session_state:
        st.session_state.results_page = 1
    
    current_page = st.session_state.results_page

    # Static display of questionnaire completion time (if recorded). This reads the stored
    # value only — we do NOT start any running timers in this view.
    completion_secs = st.session_state.get("completion_time_seconds")
    if completion_secs is not None:
        mins = int(completion_secs // 60)
        secs = int(completion_secs % 60)
        st.caption(f"⏱️ Questionnaire time: {mins}m {secs}s")
    
    # Header navigation (always visible)
    col1, col2, col3 = st.columns([2, 1, 1])
    with col1:
        st.caption(f"Page {current_page} of 5")
    with col2:
        if st.button("🔁 Start Over", use_container_width=True):
            reset_state()
            st.session_state.stage = "home"
            st.rerun()
    with col3:
        csv_data = _export_csv(st.session_state.responses, results, hotspots)
        st.download_button(
            "📥 Export",
            data=csv_data,
            file_name="mental_load_results.csv",
            mime="text/csv",
            use_container_width=True,
        )
    
    st.markdown("---")
    
    # Render current page
    if current_page == 1:
        _results_page_1_share(results, hotspots)
    elif current_page == 2:
        _results_page_2_burden(results)
    elif current_page == 3:
        _results_page_3_pillars(results)
    elif current_page == 4:
        _results_page_4_hotspots(hotspots)
    elif current_page == 5:
        _results_page_5_action()
    
    # Navigation footer (always at bottom)
    st.markdown("---")
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col1:
        if current_page > 1:
            if st.button("← Previous", use_container_width=True):
                st.session_state.results_page -= 1
                st.rerun()
        else:
            st.button("← Previous", disabled=True, use_container_width=True)
    
    with col2:
        # Page indicators
        dots = ""
        for i in range(1, 6):
            if i == current_page:
                dots += "🔵 "
            else:
                dots += "⚪ "
        st.markdown(f"<div style='text-align: center; padding: 8px;'>{dots}</div>", unsafe_allow_html=True)
    
    with col3:
        if current_page < 5:
            if st.button("Next →", use_container_width=True, type="primary"):
                st.session_state.results_page += 1
                st.rerun()
        else:
            if st.button("🏠 Finish", use_container_width=True, type="primary"):
                st.session_state.stage = "home"
                st.rerun()
    
    st.markdown("---")
    st.caption("""
    💙 **Remember:** This is one snapshot in time. Mental load shifts with life circumstances. 
    The healthiest couples check in regularly, not just once.
    """)


# ---------- Main entry point ----------
def screen_results():
    """Route to either prep screen or main results"""
    # First time seeing results? Show prep screen
    if not st.session_state.get("results_prep_seen", False):
        screen_before_results()
        st.session_state.results_prep_seen = True
    else:
        # They've seen prep, show paginated results
        screen_results_main()
----
screens/setup.py
import streamlit as st
from tasks import get_filtered_tasks

def screen_setup():
    st.header("Household context (for couples)")
    st.caption("We ask only what's needed to tailor the questionnaire.")

    c1,c2,c3 = st.columns([2,1,1])
    with c1:
        children = st.number_input("Number of children", min_value=0, max_value=10, step=1, value=st.session_state.children)
        st.session_state.children = children
    with c2:
        st.session_state.is_employed_me = st.checkbox("Partner A employed?", value=st.session_state.is_employed_me)
    with c3:
        st.session_state.is_employed_partner = st.checkbox("Partner B employed?", value=st.session_state.is_employed_partner)

    # Add pet and vehicle questions
    c4, c5 = st.columns(2)
    with c4:
        st.session_state.has_pets = st.checkbox("Do you have pets?", value=st.session_state.get('has_pets', False))
    with c5:
        st.session_state.has_vehicle = st.checkbox("Do you have a car/vehicle?", value=st.session_state.get('has_vehicle', False))

    both_employed = st.session_state.is_employed_me and st.session_state.is_employed_partner
    filtered = get_filtered_tasks(
        st.session_state.children, 
        both_employed,
        st.session_state.get('has_pets', False),
        st.session_state.get('has_vehicle', False)
    )
    
    st.success(f"{len(filtered)} items selected for your context. Child-related items only show if you have children. Pet and vehicle tasks only show if relevant.")

    if st.button("Start questionnaire →", type="primary"):
        st.session_state.q_section_index = 0
        st.session_state.q_task_index = 0
        st.session_state.responses = []
        st.session_state.notes_by_section = {}
        st.session_state.stage = "questionnaire"

----
state.py
import streamlit as st

def init_state():
    defaults = dict(
        stage="home",
        # setup
        household_type="couple",
        children=0,
        is_employed_me=True,
        is_employed_partner=True,
        has_pets=False, 
        has_vehicle=False, 
        # questionnaire progress
        q_section_index=0,
        q_task_index=0,
        responses=[],
        notes_by_section={},
        questionnaire_start_time=None,
    )
    for k,v in defaults.items():
        if k not in st.session_state:
            st.session_state[k] = v

def reset_state():
    keys = list(st.session_state.keys())
    for k in keys:
        del st.session_state[k]
    init_state()

----
streamlit/config.toml
[theme]
base="light"
primaryColor="#3b82f6"
backgroundColor="#ffffff"
secondaryBackgroundColor="#f8fafc"
textColor="#0f172a"
font="sans serif"
----
tasks.py
"""
tasks.py

This module defines the full list of household tasks used by the Mental Load Helper.
I've expanded and annotated the task catalogue so it can be filtered by household
context (children, pets, vehicles, employment status) and grouped by pillar.

Do not change task IDs casually — they're used as stable keys in session state and
CSV exports.
"""

from typing import List, Dict
from models import Task

TASKS: list[Task] = [
    # Anticipation pillar — tasks that involve planning and thinking ahead
    
    Task(
        id="meal_planning",
        name="Meal planning & grocery list",
        pillar="anticipation",
        definition=(
            "By meal planning & prep we mean the *whole* flow — not just cooking, "
            "but deciding what to eat, checking what's low, building the list, and "
            "sequencing the week so food actually happens."
        ),
        what_counts=[
            "Noticing what's low / planning the week's meals",
            "Creating or updating the grocery list / booking delivery/pick-up",
            "Remembering dietary needs, timings, after-school or late-work days",
            "Prepping ahead (marinating, batch cooking) so the week runs",
        ],
        note="Answer for the 'invisible' work here (planning/organising); the cooking task itself is separate.",
        example="If one partner mostly plans and manages the list, set Responsibility nearer their side (e.g., 70–90).",
    ),
    
    Task(
        id="household_supplies",
        name="Household supplies & consumables",
        pillar="anticipation",
        definition=(
            "Noticing when household items are running low and ensuring they're restocked before you run out."
        ),
        what_counts=[
            "Tracking toilet paper, cleaning products, toiletries",
            "Noticing when bins need new bags, dishwasher needs tablets",
            "Ordering or buying replacements before they run out",
            "Remembering what brands/types each person prefers",
        ],
        example="If one partner notices and orders everything, Responsibility ~80-100 to them.",
    ),
    
    Task(
    id="holiday_planning",
    name="Holiday & vacation planning",
    pillar="anticipation",
    definition=(
        "Planning family holidays and vacations - researching, booking, and coordinating all the details."
    ),
    what_counts=[
        "Researching holiday destinations and accommodation",
        "Booking flights, hotels, activities",
        "Planning itineraries and packing lists",
        "Coordinating time off work and school holidays",
        "Managing travel documents (passports, visas, insurance)",
    ],
    example="If one partner does most of the holiday research and booking, Responsibility ~80-100.",
),

    
    Task(
        id="birthday_gifts",
        name="Gifts, cards & social obligations",
        pillar="anticipation",
        definition=(
            "Remembering birthdays, anniversaries, and social occasions, and organising cards, gifts, or RSVPs."
        ),
        what_counts=[
            "Remembering family/friends' birthdays and important dates",
            "Choosing, buying, wrapping gifts",
            "Sending cards or organising celebrations",
            "Tracking RSVPs and social commitments",
        ],
        example="If one partner manages the family calendar of social obligations, Responsibility ~70-100.",
    ),
    
    Task(
        id="seasonal_prep",
        name="Seasonal & future planning",
        pillar="anticipation",
        definition=(
            "Thinking ahead to seasonal needs, holidays, and future household requirements."
        ),
        what_counts=[
            "Planning for holidays, school breaks, seasons changing",
            "Preparing for birthdays, Christmas, summer holidays",
            "Anticipating when kids need new clothes/shoes/school supplies",
            "Thinking ahead about home repairs or maintenance",
        ],
        example="If one partner does most of the forward-thinking, Responsibility ~70-90.",
    ),
    
    # Identification pillar — visible tasks and noticing what needs doing
    
    Task(
        id="cooking",
        name="Cooking (the visible bit)",
        pillar="identification",
        definition=(
            "This is the *doing* part — cooking the meals. It doesn't include deciding "
            "what to cook or building the shopping list (covered in Meal planning)."
        ),
        what_counts=[
            "Cooking on weekdays/weekends",
            "Warming/prepping for kids or different mealtimes",
            "Tidying as you go (if part of your norm)",
        ],
        note="If you alternate days, that's shared — use ~50.",
        example="If one partner cooks most weeknights, Responsibility might sit ~70–80.",
    ),
    
    Task(
        id="cleaning",
        name="Cleaning (routine)",
        pillar="identification",
        definition=(
            "Regular cleaning tasks and the *system* behind them (not occasional deep cleans unless that's your norm)."
        ),
        what_counts=[
            "Weekly surfaces, bathrooms, floors",
            "Small resets (dishes, counters, bins)",
            "Remembering consumables (sponges, sprays, bags)",
            "A loose rota/checklist if you use one",
        ],
        note="If one person sets the standard and nudges others, that's part of the load.",
        example="If you split weekends but one partner owns the standard, Responsibility ~60–70 to them.",
    ),
    
    Task(
        id="tidying",
        name="Tidying & decluttering",
        pillar="identification",
        definition=(
            "Noticing mess, clutter, and items out of place, and putting things back where they belong."
        ),
        what_counts=[
            "Picking up clothes, toys, items left around",
            "Putting things back in their proper places",
            "Decluttering surfaces and common areas",
            "Organising storage and cupboards",
        ],
        example="If one partner is constantly tidying up after everyone, Responsibility ~70-100.",
    ),
    
    Task(
        id="laundry",
        name="Laundry flow",
        pillar="identification",
        definition=(
            "Everything from noticing the hamper's full to finishing clean clothes in drawers. "
            "We're focusing on the *flow ownership* (who keeps it moving) rather than who folds once."
        ),
        what_counts=[
            "Noticing when to run loads; sorting/whites/darks",
            "Keeping machines cycling; moving wet clothes promptly",
            "Folding/hanging; putting away or delegating it",
            "Remembering school kits/sports days/uniforms",
        ],
        note="If one partner 'keeps it spinning' even if others help sometimes, weight toward that person.",
        example="If A notices and runs everything and B folds occasionally, Responsibility ~70–90 to A.",
    ),
    
    Task(
        id="home_maintenance",
        name="Home repairs & maintenance",
        pillar="identification",
        definition=(
            "Noticing when things break or need maintenance, and organising repairs or fixes."
        ),
        what_counts=[
            "Spotting broken items, leaks, things that need fixing",
            "Calling repair people, getting quotes",
            "Scheduling and coordinating home maintenance",
            "DIY repairs or organising someone to do them",
        ],
        example="If one partner notices and coordinates all repairs, Responsibility ~80-100.",
    ),
    Task(
    id="pet_care",
    name="Pet care & management",
    pillar="identification",
    requires_pets=True,  # conditional flag: only include when household has pets
    definition=(
        "Daily pet care and the mental load of remembering vet appointments, food, medication, and pet needs."
    ),
    what_counts=[
        "Feeding, walking, grooming pets",
        "Remembering vet appointments and vaccinations",
        "Noticing when pet food or supplies are running low",
        "Coordinating pet care when away from home",
        "Managing pet health issues and medication",
    ],
    example="If one partner manages all pet schedules and needs, Responsibility ~80-100.",
),
    # Decision pillar — tasks that require choosing, organising or deciding
    
    Task(
        id="bills_admin",
        name="Bills & admin",
        pillar="decision",
        definition=(
            "Staying on top of finances and life admin so things don't lapse or get stressful."
        ),
        what_counts=[
            "Paying rent/mortgage, utilities, subscriptions",
            "Switching providers, renewals, comparisons",
            "Budgeting, expense tracking, filing receipts",
            "Chasing missing refunds/claims",
        ],
        note="Think 'headspace ownership' — who ensures this stays under control?",
        example="If one partner runs the calendar, reminders and switches, Responsibility ~70–100.",
    ),
    
    Task(
        id="appointments_health",
        name="Appointments & health",
        pillar="decision",
        definition=(
            "Booking, tracking and following up on healthcare or essential appointments for the household."
        ),
        what_counts=[
            "Booking GP/dentist/optician; tracking reminders",
            "Booking car service/repairs if you own one",
            "Following up on results, prescriptions, referrals",
            "Keeping the household calendar up to date",
        ],
        note="If one person handles most of the coordination, weight toward them.",
        example="If A books and tracks most appointments, Responsibility ~70–90.",
    ),
    
    Task(
        id="social_calendar",
        name="Social calendar & coordination",
        pillar="decision",
        definition=(
            "Managing the household's social life, coordinating schedules, and making social plans."
        ),
        what_counts=[
            "Coordinating family/couple social plans",
            "Managing conflicting schedules between household members",
            "Deciding on weekend plans or activities",
            "Organising when to see friends and family",
        ],
        example="If one partner coordinates most social planning, Responsibility ~70-90.",
    ),
    
    Task(
        id="kids_activities",
        name="Children's activities & hobbies",
        pillar="decision",
        requires_children=True,
        definition=(
            "Researching, choosing, and enrolling children in activities, hobbies, and clubs."
        ),
        what_counts=[
            "Researching options for activities/clubs/sports",
            "Deciding what children should participate in",
            "Enrolling and managing registrations",
            "Coordinating schedules and transport",
        ],
        example="If one partner researches and enrolls children in activities, Responsibility ~80-100.",
    ),
    Task(
    id="tech_troubleshooting",
    name="Tech support & troubleshooting",
    pillar="decision",
    definition=(
        "Being the household tech support - fixing issues, managing devices, and keeping digital life running."
    ),
    what_counts=[
        "Fixing wifi/computer/phone problems",
        "Managing subscriptions and accounts (Netflix, utilities apps, etc.)",
        "Setting up new devices and software",
        "Troubleshooting when tech doesn't work",
        "Managing passwords, security, backups",
        "Being the person everyone asks when tech breaks",
    ],
    note="This is executive function work - requires problem-solving and staying calm under pressure.",
    example="If one partner is the default tech troubleshooter, Responsibility ~70-100.",
),
    # Monitoring pillar — keeping track, following up, and coordinating
    
    Task(
        id="kids_school",
        name="Children: school & schoolwork",
        pillar="monitoring",
        requires_children=True,
        definition=(
            "The orchestration behind school life — not the single pickup, but who keeps the whole system moving."
        ),
        what_counts=[
            "Remembering non-uniform days, forms, trips, fees",
            "Tracking homework and school projects",
            "Parent-teacher communication, emails, portals",
            "Monitoring children's academic progress",
        ],
        note="If you don't have children, this won't show.",
        example="If one partner is the default 'school admin', Responsibility tends to be high (e.g., 80–100).",
    ),
    
    Task(
        id="kids_health",
        name="Children's health & development",
        pillar="monitoring",
        requires_children=True,
        definition=(
            "Tracking children's health, development milestones, and medical needs."
        ),
        what_counts=[
            "Booking and attending children's health appointments",
            "Tracking vaccinations and health records",
            "Monitoring developmental milestones",
            "Noticing if children seem unwell or struggling",
        ],
        example="If one partner monitors and coordinates children's health, Responsibility ~80-100.",
    ),
    
    Task(
        id="household_calendar",
        name="Household calendar & coordination",
        pillar="monitoring",
        definition=(
            "Being the keeper of the family schedule and ensuring everyone knows where they need to be."
        ),
        what_counts=[
            "Maintaining the shared calendar",
            "Reminding others about upcoming appointments/events",
            "Coordinating who's picking up kids, who's cooking, etc.",
            "Ensuring conflicting commitments are resolved",
        ],
        example="If one partner is the 'calendar keeper', Responsibility ~80-100.",
    ),
    
    Task(
        id="food_waste",
        name="Food waste & leftovers",
        pillar="monitoring",
        definition=(
            "Tracking what food is in the fridge, using up leftovers, and preventing waste."
        ),
        what_counts=[
            "Checking what's in the fridge before it goes off",
            "Planning meals around leftovers",
            "Remembering to use ingredients before they expire",
            "Managing food storage and organisation",
        ],
        example="If one partner always knows what's in the fridge, Responsibility ~70-90.",
    ),
    
    Task(
        id="work_life_coordination",
        name="Work-life coordination",
        pillar="monitoring",
        requires_employment=True,
        definition=(
            "Managing the household around work schedules and coordinating when conflicts arise."
        ),
        what_counts=[
            "Tracking both partners' work schedules",
            "Adjusting household plans around work commitments",
            "Coordinating childcare/pickups when work runs late",
            "Managing household when one partner travels for work",
        ],
        example="If one partner does most of the 'work schedule tetris', Responsibility ~70-90.",
    ),
    Task(
    id="vehicle_maintenance",
    name="Car/vehicle maintenance",
    pillar="monitoring",
    requires_vehicle=True,  # conditional flag: only include when household has a vehicle
    definition=(
        "Tracking car servicing, MOT, insurance, and ensuring the vehicle stays roadworthy."
    ),
    what_counts=[
        "Remembering MOT and service due dates",
        "Booking and arranging car maintenance",
        "Managing car insurance renewals",
        "Noticing when car needs attention (tyres, fluids, issues)",
        "Coordinating repairs and dealing with mechanics",
    ],
    example="If one partner tracks and arranges all vehicle maintenance, Responsibility ~80-100.",
),

    # Emotional pillar — the emotional and relational work that keeps a home well
    
    Task(
        id="kids_emotional",
        name="Children's emotional wellbeing",
        pillar="emotional",
        requires_children=True,
        definition=(
            "Noticing and responding to children's emotional needs, worries, and struggles."
        ),
        what_counts=[
            "Checking in with children about their feelings",
            "Noticing when children seem upset or struggling",
            "Providing emotional support and reassurance",
            "Managing bedtime routines, soothing upsets",
        ],
        example="If one partner does most emotional check-ins, Responsibility ~80-100.",
    ),
    
    Task(
        id="relationship_maintenance",
        name="Relationship maintenance",
        pillar="emotional",
        definition=(
            "The work of maintaining your relationship - planning couple time, checking in emotionally."
        ),
        what_counts=[
            "Suggesting date nights or couple time",
            "Initiating conversations about the relationship",
            "Noticing when the relationship needs attention",
            "Remembering anniversaries and special occasions",
        ],
        example="If one partner usually suggests couple time, Responsibility ~70-90.",
    ),
    
    Task(
        id="family_relationships",
        name="Extended family relationships",
        pillar="emotional",
        definition=(
            "Managing relationships with extended family - remembering to call, organising visits, managing expectations."
        ),
        what_counts=[
            "Remembering to call/message parents, in-laws, relatives",
            "Organising family visits and gatherings",
            "Managing family expectations and conflicts",
            "Keeping family members updated on household news",
        ],
        example="If one partner manages most family communications, Responsibility ~80-100.",
    ),
    
    Task(
        id="household_mood",
        name="Household mood & atmosphere",
        pillar="emotional",
        definition=(
            "Managing the emotional atmosphere of the home - smoothing conflicts, creating positive moments."
        ),
        what_counts=[
            "Noticing when household tension is high",
            "Mediating conflicts between household members",
            "Creating positive moments (family activities, treats)",
            "Being the 'emotional thermostat' of the home",
        ],
        example="If one partner is the emotional manager, Responsibility ~80-100.",
    ),
    
    Task(
        id="partner_support",
        name="Partner emotional support",
        pillar="emotional",
        definition=(
            "Providing emotional support to your partner - listening, remembering their needs, checking in."
        ),
        what_counts=[
            "Remembering what's stressing your partner",
            "Asking how their day/work/life is going",
            "Providing emotional support and encouragement",
            "Noticing when your partner needs extra support",
        ],
        example="If one partner does most emotional checking-in, Responsibility ~70-90.",
    ),
]


TASK_LOOKUP: Dict[str, Task] = {t.id: t for t in TASKS}

def get_filtered_tasks(children: int, both_employed: bool, has_pets: bool, has_vehicle: bool) -> List[Task]:
    """
    Filter tasks based on household context.
    
    Args:
        children: Number of children
        both_employed: Whether both partners are employed
        has_pets: Whether household has pets
        has_vehicle: Whether household has a car/vehicle
    """
    out: List[Task] = []
    for t in TASKS:
        # Skip child-related tasks if no children
        if t.requires_children and children <= 0:
            continue
        # Skip employment tasks if not both employed
        if t.requires_employment and not both_employed:
            continue
        # Skip pet tasks if no pets
        if t.requires_pets and not has_pets:
            continue
        # Skip vehicle tasks if no vehicle
        if t.requires_vehicle and not has_vehicle:
            continue
        out.append(t)
    return out


def group_by_pillar(tasks: List[Task]) -> Dict[str, List[Task]]:
    d: Dict[str, List[Task]] = {}
    for t in tasks:
        d.setdefault(t.pillar, []).append(t)
    return d
----
utils/__init__.py

----
utils/dev_mode.py
# utils/dev_mode.py
import random
import streamlit as st
from tasks import get_filtered_tasks

def is_dev_mode():
    """Check if dev mode is enabled"""
    return st.session_state.get("dev_mode", False)

def toggle_dev_mode():
    """Toggle dev mode on/off"""
    st.session_state.dev_mode = not st.session_state.get("dev_mode", False)

def generate_sample_responses(scenario="balanced"):
    """
    Generate sample responses for testing
    
    Scenarios:
    - "balanced": Fairly even split (45-55 range)
    - "imbalanced": One partner carries most (70-90 range)
    - "mixed": Mix of balanced and imbalanced tasks
    - "random": Completely random
    """
    children = st.session_state.get("children", 0)
    both_employed = st.session_state.get("is_employed_me", True) and st.session_state.get("is_employed_partner", True)
    
    tasks = get_filtered_tasks(children, both_employed)
    responses = []
    
    for task in tasks:
        if scenario == "balanced":
            # Fairly balanced household
            responsibility = random.randint(40, 60)
            burden = random.randint(2, 4)
            fairness = random.randint(3, 5)
            
        elif scenario == "imbalanced":
            # Partner A carries most of the load
            responsibility = random.randint(10, 35)  # Partner A doing most
            burden = random.randint(3, 5)  # Higher burden
            fairness = random.randint(1, 3)  # Lower fairness
            
        elif scenario == "mixed":
            # Some balanced, some not
            if random.random() < 0.3:  # 30% imbalanced
                responsibility = random.choice([random.randint(10, 30), random.randint(70, 90)])
                burden = random.randint(3, 5)
                fairness = random.randint(2, 4)
            else:  # 70% balanced
                responsibility = random.randint(40, 60)
                burden = random.randint(2, 4)
                fairness = random.randint(3, 5)
                
        else:  # random
            responsibility = random.randint(0, 100)
            burden = random.randint(1, 5)
            fairness = random.randint(1, 5)
        
        responses.append({
            "task_id": task.id,
            "responsibility": responsibility,
            "burden": burden,
            "fairness": fairness,
            "not_applicable": False,
        })
    
    return responses

def populate_dev_data(scenario="balanced"):
    """Populate session state with dev data"""
    st.session_state.responses = generate_sample_responses(scenario)
    st.session_state.notes_by_section = {
        "anticipation": "Dev mode note: This section felt heavy",
        "emotional": "Dev mode note: Lots to discuss here",
    }
    st.success(f"✅ Dev mode: Populated {len(st.session_state.responses)} tasks with '{scenario}' scenario")

def dev_mode_widget():
    """Display dev mode controls in sidebar"""
    if not is_dev_mode():
        return
    
    st.sidebar.markdown("---")
    st.sidebar.markdown("### 🛠️ Dev Mode")
    
    col1, col2 = st.sidebar.columns(2)
    
    with col1:
        if st.sidebar.button("Balanced", use_container_width=True):
            populate_dev_data("balanced")
            st.rerun()
    
    with col2:
        if st.sidebar.button("Imbalanced", use_container_width=True):
            populate_dev_data("imbalanced")
            st.rerun()
    
    col3, col4 = st.sidebar.columns(2)
    
    with col3:
        if st.sidebar.button("Mixed", use_container_width=True):
            populate_dev_data("mixed")
            st.rerun()
    
    with col4:
        if st.sidebar.button("Random", use_container_width=True):
            populate_dev_data("random")
            st.rerun()
    
    if st.sidebar.button("Clear All Data", use_container_width=True):
        st.session_state.responses = []
        st.session_state.notes_by_section = {}
        st.success("✅ Cleared all data")
        st.rerun()
    
    st.sidebar.caption(f"📊 {len(st.session_state.get('responses', []))} tasks populated")
----
utils/ui.py
# utils/ui.py
import html
import streamlit as st
from typing import List, Optional

def _has_popover() -> bool:
    return hasattr(st, "popover")

def _esc(s: str) -> str:
    # Escape HTML so user text doesn’t break your markup
    return html.escape(s or "")

def step_header(title: str, subtitle: str = "", progress: int | None = None):
    st.markdown(f"### {title}")
    if subtitle:
        st.caption(subtitle)
    if isinstance(progress, int):
        st.progress(max(0, min(progress, 100)))

def learn_popover():
    ctx = st.popover("🔎 Learn / Help") if _has_popover() else st.expander("🔎 Learn / Help")
    with ctx:
        st.markdown("**What is mental load?**")
        st.write("The unseen planning, thinking and keeping-track work behind household life.")
        st.markdown("**What do sliders mean?**")
        st.write("- **Responsibility (0–100):** who mainly owns it (0 = Partner A, 100 = Partner B).")
        st.write("- **Burden (1–5):** how mentally taxing it feels.")
        st.write("- **Fairness (1–5):** how fair it feels right now.")
        st.markdown("**Tips for doing this together**")
        st.write("Talk as you go, keep it light, take a break if needed.")

def safety_note():
    st.info(
        "If anything here feels sensitive, pause and come back later. "
        "This tool is for a constructive chat, not for blame or therapy."
    )

def section_notes(key: str, placeholder: str = "Anything you noticed while answering…"):
    return st.text_area("📝 Notes for this section (optional)", key=key, height=100, placeholder=placeholder)

def tiny_hint(text: str):
    st.caption(text)

def explainer_block(title: str, bullets: List[str]):
    st.markdown(f"**{_esc(title)}**", unsafe_allow_html=True)
    for b in bullets:
        st.write(f"- {b}")

def definition_box(
    title: str,
    definition: str,
    what_counts: Optional[List[str]] = None,
    note: Optional[str] = None,
    example: Optional[str] = None,
):
    """Compact definition card used at the top of each task."""
    html_parts = [
        '<div class="card">',
        f'<div class="section-title">{_esc(title)}</div>',
        f'<p>{_esc(definition)}</p>',
    ]
    if what_counts:
        html_parts.append("<ul>")
        for item in what_counts:
            html_parts.append(f"<li>{_esc(item)}</li>")
        html_parts.append("</ul>")

    if example:
        html_parts.append(
            f'<div class="alert-info" style="margin-top:8px;"><strong>Example</strong><br>{_esc(example)}</div>'
        )

    if note:
        html_parts.append(
            f'<p style="color:#475569;margin-top:8px;"><small>{_esc(note)}</small></p>'
        )

    html_parts.append("</div>")
    st.markdown("".join(html_parts), unsafe_allow_html=True)

--END--